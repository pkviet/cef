From 8bea88163463ecb7a69fc1dd35659d2c438df5d2 Mon Sep 17 00:00:00 2001
From: pkv <pkv@obsproject.com>
Date: Sun, 4 Dec 2022 14:33:55 +0100
Subject: [PATCH] Revert "Remove GLRenderer related GL extensions"

This reverts commit 009417ac0adac8fbdaacd610b9fa5b4e80a46d3c.
---
 .../common/gpu/context_cache_controller.cc    |   1 -
 .../viz/service/display/output_surface.h      |   8 +-
 components/viz/test/test_context_support.cc   |  20 +
 components/viz/test/test_context_support.h    |  39 +
 .../CHROMIUM_commit_overlay_planes.txt        |  47 ++
 .../CHROMIUM/CHROMIUM_schedule_ca_layer.txt   | 116 +++
 .../CHROMIUM_schedule_overlay_plane.txt       |  87 +++
 .../CHROMIUM/CHROMIUM_set_draw_rectangle.txt  |  52 ++
 gpu/GLES2/gl2chromium_autogen.h               |  14 +
 gpu/GLES2/gl2extchromium.h                    | 135 ++++
 gpu/command_buffer/build_gles2_cmd_buffer.py  |  78 ++
 gpu/command_buffer/client/context_support.h   |  45 ++
 .../client/gles2_c_lib_autogen.h              | 144 ++++
 .../client/gles2_cmd_helper_autogen.h         | 146 ++++
 .../client/gles2_implementation.cc            | 235 +++++-
 .../client/gles2_implementation.h             |  31 +
 .../client/gles2_implementation_autogen.h     |  77 ++
 .../gles2_implementation_impl_autogen.h       | 114 +++
 .../gles2_implementation_unittest_autogen.h   |  53 ++
 .../client/gles2_interface_autogen.h          |  68 ++
 .../client/gles2_interface_stub_autogen.h     |  66 ++
 .../gles2_interface_stub_impl_autogen.h       |  73 ++
 .../gles2_trace_implementation_autogen.h      |  66 ++
 .../gles2_trace_implementation_impl_autogen.h | 129 +++
 gpu/command_buffer/client/gpu_control.h       |   8 +
 .../client/implementation_base.cc             |  10 +
 .../client/implementation_base.h              |   2 +
 .../client/raster_implementation.cc           |  41 +
 .../client/raster_implementation.h            |  21 +
 .../raster_implementation_gles_unittest.cc    |  25 +
 .../client/webgpu_implementation.cc           |  35 +
 .../client/webgpu_implementation.h            |  21 +
 .../common/gles2_cmd_format_autogen.h         | 734 ++++++++++++++++++
 .../common/gles2_cmd_format_test_autogen.h    | 218 ++++++
 .../common/gles2_cmd_ids_autogen.h            | 108 +--
 .../gles2_cmd_utils_implementation_autogen.h  |  40 +
 .../common/swap_buffers_flags.h               |   4 +-
 .../gles2_cmd_buffer_functions.txt            |  15 +
 gpu/command_buffer/service/decoder_client.h   |   3 +-
 gpu/command_buffer/service/gl_utils.cc        |  19 +
 .../service/gles2_cmd_decoder.cc              | 460 ++++++++++-
 .../service/gles2_cmd_decoder_autogen.h       | 145 ++++
 .../service/gles2_cmd_decoder_passthrough.cc  |   3 +-
 .../service/gles2_cmd_decoder_passthrough.h   |   3 +
 ..._cmd_decoder_passthrough_doer_prototypes.h |  69 ++
 .../gles2_cmd_decoder_passthrough_doers.cc    | 403 ++++++++++
 .../gles2_cmd_decoder_passthrough_handlers.cc |  95 +++
 ...md_decoder_passthrough_handlers_autogen.cc | 146 ++++
 .../gles2_cmd_decoder_unittest_base.cc        |   1 +
 .../service/gles2_cmd_decoder_unittest_base.h |   2 +
 ...gles2_cmd_decoder_unittest_framebuffers.cc | 100 +++
 gpu/command_buffer/tests/decoder_perftest.cc  |   2 +
 gpu/command_buffer/tests/gl_manager.cc        |   4 +
 gpu/command_buffer/tests/gl_manager.h         |   1 +
 gpu/gles2_conform_support/egl/context.cc      |   4 +
 gpu/gles2_conform_support/egl/context.h       |   1 +
 gpu/ipc/client/command_buffer_proxy_impl.cc   |   5 +
 gpu/ipc/client/command_buffer_proxy_impl.h    |   1 +
 gpu/ipc/in_process_command_buffer.cc          |  24 +
 gpu/ipc/in_process_command_buffer.h           |   4 +
 ppapi/proxy/ppapi_command_buffer_proxy.cc     |   5 +
 ppapi/proxy/ppapi_command_buffer_proxy.h      |   1 +
 ui/gl/gl_bindings.h                           |   8 +
 ui/gl/gl_enums_implementation_autogen.h       |  40 +
 64 files changed, 4612 insertions(+), 63 deletions(-)
 create mode 100644 gpu/GLES2/extensions/CHROMIUM/CHROMIUM_commit_overlay_planes.txt
 create mode 100644 gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_ca_layer.txt
 create mode 100644 gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_overlay_plane.txt
 create mode 100644 gpu/GLES2/extensions/CHROMIUM/CHROMIUM_set_draw_rectangle.txt

diff --git components/viz/common/gpu/context_cache_controller.cc components/viz/common/gpu/context_cache_controller.cc
index d9b92f6c13fa6..d511bdc6bc69b 100644
--- components/viz/common/gpu/context_cache_controller.cc
+++ components/viz/common/gpu/context_cache_controller.cc
@@ -11,7 +11,6 @@
 #include "base/check_op.h"
 #include "base/memory/ptr_util.h"
 #include "base/synchronization/lock.h"
-#include "base/time/time.h"
 #include "gpu/command_buffer/client/context_support.h"
 #include "third_party/skia/include/gpu/GrDirectContext.h"
 
diff --git components/viz/service/display/output_surface.h components/viz/service/display/output_surface.h
index 17643c6ec2234..dd75112db5ee3 100644
--- components/viz/service/display/output_surface.h
+++ components/viz/service/display/output_surface.h
@@ -201,13 +201,7 @@ class VIZ_SERVICE_EXPORT OutputSurface {
   virtual void BindFramebuffer() = 0;
 
   // Marks that the given rectangle will be drawn to on the default, bound
-  // framebuffer. The contents of the framebuffer are undefined after this
-  // command and must be filled in completely before a swap happens. Drawing
-  // outside this rectangle causes undefined behavior.
-  //
-  // Note: This is only valid to call if `capabilities().supports_dc_layers` is
-  // true. It can only be called once per swap and must be called before
-  // drawing to the default framebuffer.
+  // framebuffer. Only valid if |capabilities().supports_dc_layers| is true.
   virtual void SetDrawRectangle(const gfx::Rect& rect);
 
   // Enable or disable DC layers. Must be called before DC layers are scheduled.
diff --git components/viz/test/test_context_support.cc components/viz/test/test_context_support.cc
index 2cfefc42dd21a..1ad162d04e0cb 100644
--- components/viz/test/test_context_support.cc
+++ components/viz/test/test_context_support.cc
@@ -66,6 +66,26 @@ void TestContextSupport::CallAllSyncPointCallbacks() {
   sync_point_callbacks_.clear();
 }
 
+void TestContextSupport::SetScheduleOverlayPlaneCallback(
+    const ScheduleOverlayPlaneCallback& schedule_overlay_plane_callback) {
+  schedule_overlay_plane_callback_ = schedule_overlay_plane_callback;
+}
+
+void TestContextSupport::ScheduleOverlayPlane(
+    int plane_z_order,
+    gfx::OverlayTransform plane_transform,
+    unsigned overlay_texture_id,
+    const gfx::Rect& display_bounds,
+    const gfx::RectF& uv_rect,
+    bool enable_blend,
+    unsigned gpu_fence_id) {
+  if (!schedule_overlay_plane_callback_.is_null()) {
+    schedule_overlay_plane_callback_.Run(plane_z_order, plane_transform,
+                                         overlay_texture_id, display_bounds,
+                                         uv_rect, enable_blend, gpu_fence_id);
+  }
+}
+
 uint64_t TestContextSupport::ShareGroupTracingGUID() const {
   NOTIMPLEMENTED();
   return 0;
diff --git components/viz/test/test_context_support.h components/viz/test/test_context_support.h
index 1e6b2c686bb2b..181cc8d4e7f5c 100644
--- components/viz/test/test_context_support.h
+++ components/viz/test/test_context_support.h
@@ -17,6 +17,8 @@
 
 namespace gfx {
 class GpuFence;
+class Rect;
+class RectF;
 }  // namespace gfx
 
 namespace viz {
@@ -40,6 +42,29 @@ class TestContextSupport : public gpu::ContextSupport {
                    base::OnceCallback<void(std::unique_ptr<gfx::GpuFence>)>
                        callback) override;
   void SetAggressivelyFreeResources(bool aggressively_free_resources) override;
+  void Swap(uint32_t flags,
+            SwapCompletedCallback complete_callback,
+            PresentationCallback presentation_callback) override {}
+  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                      uint32_t flags,
+                      SwapCompletedCallback swap_completed,
+                      PresentationCallback presentation_callback) override {}
+  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
+                          uint32_t flags,
+                          SwapCompletedCallback swap_completed,
+                          PresentationCallback presentation_callback) override {
+  }
+  void CommitOverlayPlanes(
+      uint32_t flags,
+      SwapCompletedCallback swap_completed,
+      PresentationCallback presentation_callback) override {}
+  void ScheduleOverlayPlane(int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            unsigned overlay_texture_id,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& uv_rect,
+                            bool enable_blend,
+                            unsigned gpu_fence_id) override;
   uint64_t ShareGroupTracingGUID() const override;
   void SetErrorMessageCallback(
       base::RepeatingCallback<void(const char*, int32_t)> callback) override;
@@ -65,9 +90,22 @@ class TestContextSupport : public gpu::ContextSupport {
   void SetGrContext(GrDirectContext* gr) override;
   void WillCallGLFromSkia() override;
   void DidCallGLFromSkia() override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override {}
+  void SetFrameRate(float frame_rate) override {}
 
   void CallAllSyncPointCallbacks();
 
+  using ScheduleOverlayPlaneCallback =
+      base::RepeatingCallback<void(int plane_z_order,
+                                   gfx::OverlayTransform plane_transform,
+                                   unsigned overlay_texture_id,
+                                   const gfx::Rect& display_bounds,
+                                   const gfx::RectF& crop_rect,
+                                   bool enable_blend,
+                                   unsigned gpu_fence_id)>;
+  void SetScheduleOverlayPlaneCallback(
+      const ScheduleOverlayPlaneCallback& schedule_overlay_plane_callback);
+
   // If set true, callbacks triggering will be in a reverse order as SignalQuery
   // calls.
   void set_out_of_order_callbacks(bool out_of_order_callbacks) {
@@ -76,6 +114,7 @@ class TestContextSupport : public gpu::ContextSupport {
 
  private:
   std::vector<base::OnceClosure> sync_point_callbacks_;
+  ScheduleOverlayPlaneCallback schedule_overlay_plane_callback_;
   bool out_of_order_callbacks_;
 
   base::WeakPtrFactory<TestContextSupport> weak_ptr_factory_{this};
diff --git gpu/GLES2/extensions/CHROMIUM/CHROMIUM_commit_overlay_planes.txt gpu/GLES2/extensions/CHROMIUM/CHROMIUM_commit_overlay_planes.txt
new file mode 100644
index 0000000000000..7e328771782ab
--- /dev/null
+++ gpu/GLES2/extensions/CHROMIUM/CHROMIUM_commit_overlay_planes.txt
@@ -0,0 +1,47 @@
+Name
+
+    CHROMIUM_commit_overlay_planes
+
+Name Strings
+
+    GL_CHROMIUM_commit_overlay_planes
+
+Version
+
+    Last Modified Date: Nov 23, 2015
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+
+Overview
+
+    This extension allows a client to request the display of hardware overlay
+    planes that have been scheduled with glScheduleOverlayPlaneCHROMIUM since
+    the last call to glSwapBuffers, glPostSubBufferCHROMIUM, or
+    glCommitOverlayPlanesCHROMIUM. This allows a client to display overlay
+    planes without swapping the framebuffer.
+
+    Issues
+
+    None
+
+New Tokens
+
+    None
+
+New Procedures and Functions
+
+    The command
+
+        glCommitOverlayPlanesCHROMIUM ();
+
+    Displays the scheduled overlay planes.
+
+Errors
+
+    None.
+
+New State
+
+    None.
diff --git gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_ca_layer.txt gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_ca_layer.txt
new file mode 100644
index 0000000000000..06d26ee7464b2
--- /dev/null
+++ gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_ca_layer.txt
@@ -0,0 +1,116 @@
+Name
+
+    CHROMIUM_schedule_ca_layer
+
+Name Strings
+
+    GL_CHROMIUM_schedule_ca_layer
+
+Version
+
+    Last Modified Date: April 12, 2016
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+
+Overview
+
+    This extension allows a client to request a texture be presented as a
+    CoreAnimation layer. The expectation is that all the CALayers scheduled
+    since the last call to glSwapBuffers or glPostSubBufferCHROMIUM are
+    displayed atomically at the time of the next call to swap buffers. Scheduled
+    CALayers are not stateful and need to be rescheduled after the buffers were
+    swapped.
+
+Issues
+
+    None
+
+New Tokens
+
+    Accepted by the <edge_aa_mask> parameter of glScheduleCALayerCHROMIUM:
+    GL_CA_LAYER_EDGE_LEFT_CHROMIUM                    0x01
+    GL_CA_LAYER_EDGE_RIGHT_CHROMIUM                   0x02
+    GL_CA_LAYER_EDGE_BOTTOM_CHROMIUM                  0x04
+    GL_CA_LAYER_EDGE_TOP_CHROMIUM                     0x08
+
+New Procedures and Functions
+
+    The command
+
+        glScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                             GLboolean is_clipped,
+                                             const GLfloat* clip_rect,
+                                             GLint sorting_context_id,
+                                             const GLfloat* transform);
+
+    sets state that will be shared by each subsequent call to
+    glScheduleCALayerCHROMIUM. A subsequent call to
+    glScheduleCALayerSharedStateCHROMIUM overrides the previous shared state
+    values. A call to glSwapBuffers clears the shared state values.
+    <opacity> specifies the opacity of the CALayer.
+    <is_clipped> indicates if the layer should be clipped.
+    <clip_rect> contains four values indicating the x, y, width, and height of
+    the rectangle to clip the layer to, if it is to be clipped.
+    <sorting_context_id> Layers in a non-zero sorting context exist in the same
+    3D space and should intersect.
+    <transform> contains sixteen values indicating the row major order 4x4
+    transformation matrix to apply to the CALayer.
+
+    The command
+
+        glScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                                  const GLfloat* contents_rect,
+                                  GLuint background_color,
+                                  GLuint edge_aa_mask,
+                                  const GLfloat* bounds_rect,
+                                  GLuint filter);
+
+    requires that shared state has been previously set by
+    glScheduleCALayerSharedStateCHROMIUM. It sets the CALayer parameters to be
+    presented at the time of the next call to swap buffers. The order of the
+    calls schedule CALayers determines their back-to-front presentation order.
+    <contents_texture_id> is the texture to be presented. If zero, then the
+    CALayer will be a solid color.
+    <contents_rect> contains four values indicating the x, y, width, and height
+    of the sub-rectangle to display from the texture specified in
+    <contents_texture_id>, in normalized coordinates.
+    <background_color> specifies the background color of the CALayer, as a
+    32-bit ARGB value.
+    <edge_aa_mask> is a bitfield specifying which of the edges of the layer are
+    to have anti-aliasing.
+    <bounds_rect> contains four values indicating the x, y, width, and height of
+    the layer in pixels.
+    <filter> will be used for both minification and magnification filtering. The
+    only valid values are GL_LINEAR and GL_NEAREST.
+
+    The command
+
+       glScheduleCALayerInUseQueryCHROMIUM(GLsizei count, GLuint* textures);
+
+    schedules a query at the time of the next call to swap buffers. If the given
+    texture is backed by an IOSurface, then the query checks to see whether the
+    IOSurface is in use by the Window Server. Otherwise, the query returns
+    false. All the results will be returned with the swap ACK in
+    SwapBuffersCompleteParams. Clients should not destroy any textures while
+    they are being queried, as the swap ACK will use the original texture id to
+    identify the queried textures.
+
+Errors
+
+    GL_INVALID_OPERATION is generated when glScheduleCALayerCHROMIUM is called
+    without a prior call to glScheduleCALayerSharedStateCHROMIUM.
+
+New State
+
+    None.
+
+Revision History
+
+    6/13/2016    Add glScheduleCALayerInUseQueryCHROMIUM.
+    4/12/2016    Add a parameter to support minification and magnification
+                 filtering.
+    12/16/2015   Add clipping and edge anti-aliasing.
+    11/7/2015    Initial checkin
+
diff --git gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_overlay_plane.txt gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_overlay_plane.txt
new file mode 100644
index 0000000000000..d88344db84782
--- /dev/null
+++ gpu/GLES2/extensions/CHROMIUM/CHROMIUM_schedule_overlay_plane.txt
@@ -0,0 +1,87 @@
+Name
+
+    CHROMIUM_schedule_overlay_plane
+
+Name Strings
+
+    GL_CHROMIUM_schedule_overlay_plane
+
+Version
+
+    Last Modified Date: March 28, 2018
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+
+Overview
+
+    This extension allows a client to request a texture be presented as a
+    hardware overlay plane along with the framebuffer. The expectation is that
+    all the planes scheduled since the last call to glSwapBuffers or
+    glPostSubBufferCHROMIUM are displayed atomically with the framebuffer during
+    the next call to swap buffers. Scheduled planes are not stateful and need
+    to be rescheduled after the buffers were swapped.
+
+    This extension could be used in conjunction with OES_EGL_image_external
+    to render into buffers suitable for scanout and present them directly
+    via display hardware without further compositing in GLES.
+
+    An example use case would be displaying a video buffer which was decoded by
+    dedicated hardware as part of a GLES application.
+
+Issues
+
+    None
+
+New Tokens
+
+    None
+
+New Procedures and Functions
+
+    The command
+
+        glScheduleOverlayPlaneCHROMIUM (GLint plane_z_order,
+                                        GLenum plane_transform,
+                                        GLuint overlay_texture_id,
+                                        GLint bounds_x,
+                                        GLint bounds_y,
+                                        GLint bounds_width,
+                                        GLint bounds_height,
+                                        GLfloat uv_x,
+                                        GLfloat uv_y,
+                                        GLfloat uv_width,
+                                        GLfloat uv_height
+                                        GLboolean enable_blend,
+                                        GLuint gpu_fence_id);
+
+    Sets the overlay plane to be presented synchronously along with the primary
+    framebuffer during the call to swap buffers.
+    <plane_z_order> specifies the stacking order of the plane relative to the
+    main framebuffer located at index 0.
+    <plane_transform> specifies how the buffer is to be transformed during
+    composition.
+    <overlay_texture_id> is the buffer to be presented by the overlay.
+    <bounds_x>, <bounds_y>, <bounds_width>, <bounds_height> specify where it is
+    supposed to be on the screen.
+    <uv_x>, <uv_y>, <uv_width>, <uv_height> specify the region within the
+    buffer to be placed inside the bounds.
+    <enable_blend> specifies whether alpha blending should be enabled or
+    disabled when the buffer is presented.
+    <gpu_fence_id> is the id of a gpu fence which when signaled marks that the
+    the buffer is ready to be presented as an overlay.
+
+Errors
+
+    None.
+
+New State
+
+    None.
+
+Revision History
+
+    04/02/2014    Documented the extension
+    03/18/2018    Added enable_blend parameter
+    03/28/2018    Added gpu_fence_id parameter
diff --git gpu/GLES2/extensions/CHROMIUM/CHROMIUM_set_draw_rectangle.txt gpu/GLES2/extensions/CHROMIUM/CHROMIUM_set_draw_rectangle.txt
new file mode 100644
index 0000000000000..5dd039d523b8a
--- /dev/null
+++ gpu/GLES2/extensions/CHROMIUM/CHROMIUM_set_draw_rectangle.txt
@@ -0,0 +1,52 @@
+Name
+
+    CHROMIUM_set_draw_rectangle
+
+Name Strings
+
+    GL_CHROMIUM_set_draw_rectangle
+
+Version
+
+    Last Modified Date: Jan 23, 2017
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+
+Overview
+
+    This extension allows a client to indicate what area is going to be drawn to.
+
+Issues
+
+    None
+
+New Tokens
+
+    None
+
+New Procedures and Functions
+
+    The command
+
+        glSetDrawRectangleCHROMIUM (GLint x, GLint y, GLint width, GLint height);
+
+    indicates that the client will fill in the entire rectangle specified of
+    the default framebuffer. This command can only be specified once per swap.
+    If the extension is supported, this function must be called before any
+    drawing to the default framebuffer. The contents of the framebuffer are
+    undefined after this command and must be filled in completely before a
+    swap happens. Rendering outside this rectangle causes undefined behavior,
+    and the scissor test must be enabled when drawing.
+
+    For the first call to this, and the first call after a resize, the
+    rectangle must be equal to the size of the entire buffer.
+
+Errors
+
+    None.
+
+New State
+
+    None.
diff --git gpu/GLES2/gl2chromium_autogen.h gpu/GLES2/gl2chromium_autogen.h
index 77142db3b504a..5a9490052b8f1 100644
--- gpu/GLES2/gl2chromium_autogen.h
+++ gpu/GLES2/gl2chromium_autogen.h
@@ -316,6 +316,7 @@
   GLES2_GET_FUN(DescheduleUntilFinishedCHROMIUM)
 #define glGetTranslatedShaderSourceANGLE \
   GLES2_GET_FUN(GetTranslatedShaderSourceANGLE)
+#define glPostSubBufferCHROMIUM GLES2_GET_FUN(PostSubBufferCHROMIUM)
 #define glCopyTextureCHROMIUM GLES2_GET_FUN(CopyTextureCHROMIUM)
 #define glCopySubTextureCHROMIUM GLES2_GET_FUN(CopySubTextureCHROMIUM)
 #define glDrawArraysInstancedANGLE GLES2_GET_FUN(DrawArraysInstancedANGLE)
@@ -336,8 +337,17 @@
 #define glLoseContextCHROMIUM GLES2_GET_FUN(LoseContextCHROMIUM)
 #define glDrawBuffersEXT GLES2_GET_FUN(DrawBuffersEXT)
 #define glDiscardBackbufferCHROMIUM GLES2_GET_FUN(DiscardBackbufferCHROMIUM)
+#define glScheduleOverlayPlaneCHROMIUM \
+  GLES2_GET_FUN(ScheduleOverlayPlaneCHROMIUM)
+#define glScheduleCALayerSharedStateCHROMIUM \
+  GLES2_GET_FUN(ScheduleCALayerSharedStateCHROMIUM)
+#define glScheduleCALayerCHROMIUM GLES2_GET_FUN(ScheduleCALayerCHROMIUM)
+#define glScheduleCALayerInUseQueryCHROMIUM \
+  GLES2_GET_FUN(ScheduleCALayerInUseQueryCHROMIUM)
+#define glCommitOverlayPlanesCHROMIUM GLES2_GET_FUN(CommitOverlayPlanesCHROMIUM)
 #define glFlushDriverCachesCHROMIUM GLES2_GET_FUN(FlushDriverCachesCHROMIUM)
 #define glGetLastFlushIdCHROMIUM GLES2_GET_FUN(GetLastFlushIdCHROMIUM)
+#define glScheduleDCLayerCHROMIUM GLES2_GET_FUN(ScheduleDCLayerCHROMIUM)
 #define glSetActiveURLCHROMIUM GLES2_GET_FUN(SetActiveURLCHROMIUM)
 #define glContextVisibilityHintCHROMIUM \
   GLES2_GET_FUN(ContextVisibilityHintCHROMIUM)
@@ -348,6 +358,10 @@
   GLES2_GET_FUN(BindFragDataLocationIndexedEXT)
 #define glBindFragDataLocationEXT GLES2_GET_FUN(BindFragDataLocationEXT)
 #define glGetFragDataIndexEXT GLES2_GET_FUN(GetFragDataIndexEXT)
+#define glSwapBuffersWithBoundsCHROMIUM \
+  GLES2_GET_FUN(SwapBuffersWithBoundsCHROMIUM)
+#define glSetDrawRectangleCHROMIUM GLES2_GET_FUN(SetDrawRectangleCHROMIUM)
+#define glSetEnableDCLayersCHROMIUM GLES2_GET_FUN(SetEnableDCLayersCHROMIUM)
 #define glInitializeDiscardableTextureCHROMIUM \
   GLES2_GET_FUN(InitializeDiscardableTextureCHROMIUM)
 #define glUnlockDiscardableTextureCHROMIUM \
diff --git gpu/GLES2/gl2extchromium.h gpu/GLES2/gl2extchromium.h
index 1c79a5436e493..ddaec6f5b1e99 100644
--- gpu/GLES2/gl2extchromium.h
+++ gpu/GLES2/gl2extchromium.h
@@ -142,6 +142,25 @@ typedef void (GL_APIENTRYP PFNGLREQUESTEXTENSIONCHROMIUMPROC) (
 #endif
 #endif  /* GL_CHROMIUM_get_error_query */
 
+/* GL_CHROMIUM_post_sub_buffer */
+#ifndef GL_CHROMIUM_post_sub_buffer
+#define GL_CHROMIUM_post_sub_buffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glPostSubBufferCHROMIUM(GLuint64 swap_id,
+                                                    GLint x,
+                                                    GLint y,
+                                                    GLint width,
+                                                    GLint height,
+                                                    GLbitfield flags);
+#endif
+typedef void(GL_APIENTRYP PFNGLPOSTSUBBUFFERCHROMIUMPROC)(GLuint64 swap_id,
+                                                          GLint x,
+                                                          GLint y,
+                                                          GLint width,
+                                                          GLint height,
+                                                          GLbitfield flags);
+#endif  /* GL_CHROMIUM_post_sub_buffer */
+
 /* GL_CHROMIUM_bind_uniform_location */
 #ifndef GL_CHROMIUM_bind_uniform_location
 #define GL_CHROMIUM_bind_uniform_location 1
@@ -623,6 +642,122 @@ typedef void (GL_APIENTRYP PFNGLWAITSYNCTOKENCHROMIUM) (
 #endif
 #endif /* GL_CHROMIUM_color_buffer_float_rgb */
 
+/* GL_CHROMIUM_schedule_overlay_plane */
+#ifndef GL_CHROMIUM_schedule_overlay_plane
+#define GL_CHROMIUM_schedule_overlay_plane 1
+
+#ifndef GL_OVERLAY_TRANSFORM_NONE_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_NONE_CHROMIUM 0x9245
+#endif
+
+#ifndef GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM 0x9246
+#endif
+
+#ifndef GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM 0x9247
+#endif
+
+#ifndef GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM 0x9248
+#endif
+
+#ifndef GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM 0x9249
+#endif
+
+#ifndef GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM
+#define GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM 0x924A
+#endif
+
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY
+glScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                               GLenum plane_transform,
+                               GLuint overlay_texture_id,
+                               GLint bounds_x,
+                               GLint bounds_y,
+                               GLint bounds_width,
+                               GLint bounds_height,
+                               GLfloat uv_x,
+                               GLfloat uv_y,
+                               GLfloat uv_width,
+                               GLfloat uv_height,
+                               GLboolean enable_blend,
+                               GLuint gpu_fence_id);
+#endif
+typedef void(GL_APIENTRYP PFNGLSCHEDULEOVERLAYPLANECHROMIUMPROC)(
+    GLint plane_z_order,
+    GLenum plane_transform,
+    GLuint overlay_texture_id,
+    GLint bounds_x,
+    GLint bounds_y,
+    GLint bounds_width,
+    GLint bounds_height,
+    GLfloat uv_x,
+    GLfloat uv_y,
+    GLfloat uv_width,
+    GLfloat uv_height,
+    GLboolean enable_blend,
+    GLuint gpu_fence_id);
+#endif /* GL_CHROMIUM_schedule_overlay_plane */
+
+#ifndef GL_CHROMIUM_schedule_ca_layer
+#define GL_CHROMIUM_schedule_ca_layer 1
+
+#ifndef GL_CA_LAYER_EDGE_LEFT_CHROMIUM
+#define GL_CA_LAYER_EDGE_LEFT_CHROMIUM 0x1
+#endif
+
+#ifndef GL_CA_LAYER_EDGE_RIGHT_CHROMIUM
+#define GL_CA_LAYER_EDGE_RIGHT_CHROMIUM 0x2
+#endif
+
+#ifndef GL_CA_LAYER_EDGE_BOTTOM_CHROMIUM
+#define GL_CA_LAYER_EDGE_BOTTOM_CHROMIUM 0x4
+#endif
+
+#ifndef GL_CA_LAYER_EDGE_TOP_CHROMIUM
+#define GL_CA_LAYER_EDGE_TOP_CHROMIUM 0x8
+#endif
+
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY
+glScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                     GLboolean is_clipped,
+                                     const GLfloat* clip_rect,
+                                     const GLfloat* rounded_corner_bounds,
+                                     GLint sorting_context_id,
+                                     const GLfloat* transform);
+GL_APICALL void GL_APIENTRY
+glScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                          const GLfloat* contents_rect,
+                          GLuint background_color,
+                          GLuint edge_aa_mask,
+                          const GLfloat* bounds_rect,
+                          GLuint filter);
+GL_APICALL void GL_APIENTRY
+glScheduleCALayerInUseQueryCHROMIUM(GLsizei count, const GLuint* textures);
+#endif
+typedef void(GL_APIENTRYP PFNGLSCHEDULECALAYERSHAREDSTATECHROMIUMPROC)(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    GLfloat clip_rect_corner_radius,
+    GLint sorting_context_id,
+    const GLfloat* transform);
+typedef void(GL_APIENTRYP PFNGLSCHEDULECALAYERCHROMIUMPROC)(
+    GLuint contents_texture_id,
+    const GLfloat* contents_rect,
+    GLuint background_color,
+    GLuint edge_aa_mask,
+    const GLfloat* bounds_rect,
+    GLuint filter);
+typedef void(GL_APIENTRYP PFNGLSCHEDULECALAYERINUSEQUERYCHROMIUMPROC)(
+    GLsizei count,
+    const GLuint* textures);
+#endif /* GL_CHROMIUM_schedule_ca_layer */
+
 /* GL_CHROMIUM_sync_query */
 #ifndef GL_CHROMIUM_sync_query
 #define GL_CHROMIUM_sync_query 1
diff --git gpu/command_buffer/build_gles2_cmd_buffer.py gpu/command_buffer/build_gles2_cmd_buffer.py
index b9bb0dfab56c9..4530b7f14100e 100755
--- gpu/command_buffer/build_gles2_cmd_buffer.py
+++ gpu/command_buffer/build_gles2_cmd_buffer.py
@@ -3093,6 +3093,12 @@ _FUNCTION_INFO = {
     'type': 'Custom',
     'impl_func': False,
   },
+  'PostSubBufferCHROMIUM': {
+    'type': 'Custom',
+    'impl_func': False,
+    'client_test': False,
+    'extension': True,
+  },
   'ProduceTextureDirectCHROMIUM': {
     'decoder_func': 'DoProduceTextureDirectCHROMIUM',
     'impl_func': False,
@@ -3246,6 +3252,15 @@ _FUNCTION_INFO = {
     'trace_level': 1,
     'trace_queueing_flow': True,
   },
+  'SwapBuffersWithBoundsCHROMIUM': {
+    'type': 'PUTn',
+    'count': 4,
+    'decoder_func': 'DoSwapBuffersWithBoundsCHROMIUM',
+    'impl_func': False,
+    'client_test': False,
+    'unit_test': False,
+    'extension': True,
+  },
   'TexImage2D': {
     'type': 'Custom',
     'impl_func': False,
@@ -3927,6 +3942,69 @@ _FUNCTION_INFO = {
     'extension': True,
     'trace_level': 2,
   },
+  'ScheduleOverlayPlaneCHROMIUM': {
+    'type': 'Custom',
+    'client_test': False,
+    'extension': 'CHROMIUM_schedule_overlay_plane',
+  },
+  'ScheduleCALayerSharedStateCHROMIUM': {
+    'type': 'Custom',
+    'impl_func': False,
+    'client_test': False,
+    'cmd_args': 'GLfloat opacity, GLboolean is_clipped, '
+                'GLint sorting_context_id, '
+                'GLuint shm_id, GLuint shm_offset',
+    'extension': 'CHROMIUM_schedule_ca_layer',
+  },
+  'ScheduleCALayerCHROMIUM': {
+    'type': 'Custom',
+    'impl_func': False,
+    'client_test': False,
+    'cmd_args': 'GLuint contents_texture_id, GLuint background_color, '
+                'GLuint edge_aa_mask, GLuint filter, GLuint shm_id, '
+                'GLuint shm_offset',
+    'extension': 'CHROMIUM_schedule_ca_layer',
+  },
+  'ScheduleCALayerInUseQueryCHROMIUM': {
+    'type': 'PUTn',
+    'count': 1,
+    'decoder_func': 'DoScheduleCALayerInUseQueryCHROMIUM',
+    'cmd_args': 'GLsizei count, const GLuint* textures',
+    'extension': 'CHROMIUM_schedule_ca_layer',
+    'unit_test': False,
+  },
+  'ScheduleDCLayerCHROMIUM': {
+    'cmd_args': 'GLuint texture_0, GLuint texture_1, GLint z_order, '
+                'GLint content_x, GLint content_y, GLint content_width, '
+                'GLint content_height, GLint quad_x, GLint quad_y, '
+                'GLint quad_width, GLint quad_height, '
+                'GLfloat transform_c1r1, GLfloat transform_c2r1, '
+                'GLfloat transform_c1r2, GLfloat transform_c2r2, '
+                'GLfloat transform_tx, GLfloat transform_ty, '
+                'GLboolean is_clipped, GLint clip_x, GLint clip_y, '
+                'GLint clip_width, GLint clip_height, '
+                'GLuint protected_video_type',
+    'decoder_func': 'DoScheduleDCLayerCHROMIUM',
+    'extension': 'CHROMIUM_schedule_dc_layer',
+    'unit_test': False,
+  },
+  'CommitOverlayPlanesCHROMIUM': {
+    'impl_func': False,
+    'decoder_func': 'DoCommitOverlayPlanes',
+    'unit_test': False,
+    'client_test': False,
+    'extension': 'CHROMIUM_commit_overlay_planes',
+  },
+  'SetDrawRectangleCHROMIUM': {
+    'decoder_func': 'DoSetDrawRectangleCHROMIUM',
+    'unit_test': False,
+    'extension': 'CHROMIUM_set_draw_rectangle',
+  },
+  'SetEnableDCLayersCHROMIUM': {
+    'decoder_func': 'DoSetEnableDCLayersCHROMIUM',
+    'unit_test': False,
+    'extension': 'CHROMIUM_dc_layers',
+  },
   'InitializeDiscardableTextureCHROMIUM': {
     'type': 'Custom',
     'cmd_args': 'GLuint texture_id, uint32_t shm_id, '
diff --git gpu/command_buffer/client/context_support.h gpu/command_buffer/client/context_support.h
index 9639c52f44bca..086bf53ecef0e 100644
--- gpu/command_buffer/client/context_support.h
+++ gpu/command_buffer/client/context_support.h
@@ -11,11 +11,14 @@
 #include "base/callback.h"
 #include "ui/gfx/gpu_fence_handle.h"
 #include "ui/gfx/overlay_transform.h"
+#include "ui/gfx/presentation_feedback.h"
 
 class GrDirectContext;
 
 namespace gfx {
 class GpuFence;
+class Rect;
+class RectF;
 }
 
 namespace cc {
@@ -24,6 +27,7 @@ struct ImageHeaderMetadata;
 
 namespace gpu {
 
+struct SwapBuffersCompleteParams;
 struct SyncToken;
 
 class ContextSupport {
@@ -56,6 +60,39 @@ class ContextSupport {
   virtual void SetAggressivelyFreeResources(
       bool aggressively_free_resources) = 0;
 
+  using SwapCompletedCallback =
+      base::OnceCallback<void(const SwapBuffersCompleteParams&,
+                              gfx::GpuFenceHandle)>;
+  using PresentationCallback =
+      base::OnceCallback<void(const gfx::PresentationFeedback&)>;
+  virtual void Swap(uint32_t flags,
+                    SwapCompletedCallback complete_callback,
+                    PresentationCallback presentation_callback) = 0;
+  virtual void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                              uint32_t flags,
+                              SwapCompletedCallback swap_completed,
+                              PresentationCallback presentation_callback) = 0;
+  virtual void PartialSwapBuffers(
+      const gfx::Rect& sub_buffer,
+      uint32_t flags,
+      SwapCompletedCallback swap_completed,
+      PresentationCallback presentation_callback) = 0;
+  virtual void CommitOverlayPlanes(
+      uint32_t flags,
+      SwapCompletedCallback swap_completed,
+      PresentationCallback presentation_callback) = 0;
+
+  // Schedule a texture to be presented as an overlay synchronously with the
+  // primary surface during the next buffer swap or CommitOverlayPlanes.
+  // This method is not stateful and needs to be re-scheduled every frame.
+  virtual void ScheduleOverlayPlane(int plane_z_order,
+                                    gfx::OverlayTransform plane_transform,
+                                    unsigned overlay_texture_id,
+                                    const gfx::Rect& display_bounds,
+                                    const gfx::RectF& uv_rect,
+                                    bool enable_blend,
+                                    unsigned gpu_fence_id) = 0;
+
   // Returns an ID that can be used to globally identify the share group that
   // this context's resources belong to.
   virtual uint64_t ShareGroupTracingGUID() const = 0;
@@ -129,6 +166,14 @@ class ContextSupport {
 
   virtual void DidCallGLFromSkia() = 0;
 
+  // Notifies the onscreen surface of the display transform applied to the swaps
+  // from the client.
+  virtual void SetDisplayTransform(gfx::OverlayTransform transform) = 0;
+
+  // Notifies the onscreen surface of the rate at which content is being
+  // updated.
+  virtual void SetFrameRate(float frame_rate) = 0;
+
  protected:
   ContextSupport() = default;
   virtual ~ContextSupport() = default;
diff --git gpu/command_buffer/client/gles2_c_lib_autogen.h gpu/command_buffer/client/gles2_c_lib_autogen.h
index feb9f6eb0b49c..2ab5f0fb8eaca 100644
--- gpu/command_buffer/client/gles2_c_lib_autogen.h
+++ gpu/command_buffer/client/gles2_c_lib_autogen.h
@@ -1461,6 +1461,15 @@ void GL_APIENTRY GLES2GetTranslatedShaderSourceANGLE(GLuint shader,
   gles2::GetGLContext()->GetTranslatedShaderSourceANGLE(shader, bufsize, length,
                                                         source);
 }
+void GL_APIENTRY GLES2PostSubBufferCHROMIUM(GLuint64 swap_id,
+                                            GLint x,
+                                            GLint y,
+                                            GLint width,
+                                            GLint height,
+                                            GLbitfield flags) {
+  gles2::GetGLContext()->PostSubBufferCHROMIUM(swap_id, x, y, width, height,
+                                               flags);
+}
 void GL_APIENTRY GLES2CopyTextureCHROMIUM(GLuint source_id,
                                           GLint source_level,
                                           GLenum dest_target,
@@ -1567,12 +1576,89 @@ void GL_APIENTRY GLES2DrawBuffersEXT(GLsizei count, const GLenum* bufs) {
 void GL_APIENTRY GLES2DiscardBackbufferCHROMIUM() {
   gles2::GetGLContext()->DiscardBackbufferCHROMIUM();
 }
+void GL_APIENTRY GLES2ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                                   GLenum plane_transform,
+                                                   GLuint overlay_texture_id,
+                                                   GLint bounds_x,
+                                                   GLint bounds_y,
+                                                   GLint bounds_width,
+                                                   GLint bounds_height,
+                                                   GLfloat uv_x,
+                                                   GLfloat uv_y,
+                                                   GLfloat uv_width,
+                                                   GLfloat uv_height,
+                                                   GLboolean enable_blend,
+                                                   GLuint gpu_fence_id) {
+  gles2::GetGLContext()->ScheduleOverlayPlaneCHROMIUM(
+      plane_z_order, plane_transform, overlay_texture_id, bounds_x, bounds_y,
+      bounds_width, bounds_height, uv_x, uv_y, uv_width, uv_height,
+      enable_blend, gpu_fence_id);
+}
+void GL_APIENTRY
+GLES2ScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                        GLboolean is_clipped,
+                                        const GLfloat* clip_rect,
+                                        const GLfloat* rounded_corner_bounds,
+                                        GLint sorting_context_id,
+                                        const GLfloat* transform) {
+  gles2::GetGLContext()->ScheduleCALayerSharedStateCHROMIUM(
+      opacity, is_clipped, clip_rect, rounded_corner_bounds, sorting_context_id,
+      transform);
+}
+void GL_APIENTRY GLES2ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                                              const GLfloat* contents_rect,
+                                              GLuint background_color,
+                                              GLuint edge_aa_mask,
+                                              const GLfloat* bounds_rect,
+                                              GLuint filter) {
+  gles2::GetGLContext()->ScheduleCALayerCHROMIUM(
+      contents_texture_id, contents_rect, background_color, edge_aa_mask,
+      bounds_rect, filter);
+}
+void GL_APIENTRY
+GLES2ScheduleCALayerInUseQueryCHROMIUM(GLsizei count, const GLuint* textures) {
+  gles2::GetGLContext()->ScheduleCALayerInUseQueryCHROMIUM(count, textures);
+}
+void GL_APIENTRY GLES2CommitOverlayPlanesCHROMIUM(GLuint64 swap_id,
+                                                  GLbitfield flags) {
+  gles2::GetGLContext()->CommitOverlayPlanesCHROMIUM(swap_id, flags);
+}
 void GL_APIENTRY GLES2FlushDriverCachesCHROMIUM() {
   gles2::GetGLContext()->FlushDriverCachesCHROMIUM();
 }
 GLuint GL_APIENTRY GLES2GetLastFlushIdCHROMIUM() {
   return gles2::GetGLContext()->GetLastFlushIdCHROMIUM();
 }
+void GL_APIENTRY GLES2ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                              GLuint texture_1,
+                                              GLint z_order,
+                                              GLint content_x,
+                                              GLint content_y,
+                                              GLint content_width,
+                                              GLint content_height,
+                                              GLint quad_x,
+                                              GLint quad_y,
+                                              GLint quad_width,
+                                              GLint quad_height,
+                                              GLfloat transform_c1r1,
+                                              GLfloat transform_c2r1,
+                                              GLfloat transform_c1r2,
+                                              GLfloat transform_c2r2,
+                                              GLfloat transform_tx,
+                                              GLfloat transform_ty,
+                                              GLboolean is_clipped,
+                                              GLint clip_x,
+                                              GLint clip_y,
+                                              GLint clip_width,
+                                              GLint clip_height,
+                                              GLuint protected_video_type) {
+  gles2::GetGLContext()->ScheduleDCLayerCHROMIUM(
+      texture_0, texture_1, z_order, content_x, content_y, content_width,
+      content_height, quad_x, quad_y, quad_width, quad_height, transform_c1r1,
+      transform_c2r1, transform_c1r2, transform_c2r2, transform_tx,
+      transform_ty, is_clipped, clip_x, clip_y, clip_width, clip_height,
+      protected_video_type);
+}
 void GL_APIENTRY GLES2SetActiveURLCHROMIUM(const char* url) {
   gles2::GetGLContext()->SetActiveURLCHROMIUM(url);
 }
@@ -1603,6 +1689,22 @@ void GL_APIENTRY GLES2BindFragDataLocationEXT(GLuint program,
 GLint GL_APIENTRY GLES2GetFragDataIndexEXT(GLuint program, const char* name) {
   return gles2::GetGLContext()->GetFragDataIndexEXT(program, name);
 }
+void GL_APIENTRY GLES2SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                                    GLsizei count,
+                                                    const GLint* rects,
+                                                    GLbitfield flags) {
+  gles2::GetGLContext()->SwapBuffersWithBoundsCHROMIUM(swap_id, count, rects,
+                                                       flags);
+}
+void GL_APIENTRY GLES2SetDrawRectangleCHROMIUM(GLint x,
+                                               GLint y,
+                                               GLint width,
+                                               GLint height) {
+  gles2::GetGLContext()->SetDrawRectangleCHROMIUM(x, y, width, height);
+}
+void GL_APIENTRY GLES2SetEnableDCLayersCHROMIUM(GLboolean enabled) {
+  gles2::GetGLContext()->SetEnableDCLayersCHROMIUM(enabled);
+}
 void GL_APIENTRY GLES2InitializeDiscardableTextureCHROMIUM(GLuint texture_id) {
   gles2::GetGLContext()->InitializeDiscardableTextureCHROMIUM(texture_id);
 }
@@ -2876,6 +2978,10 @@ extern const NameToFunc g_gles2_function_table[] = {
         reinterpret_cast<GLES2FunctionPointer>(
             glGetTranslatedShaderSourceANGLE),
     },
+    {
+        "glPostSubBufferCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glPostSubBufferCHROMIUM),
+    },
     {
         "glCopyTextureCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glCopyTextureCHROMIUM),
@@ -2943,6 +3049,28 @@ extern const NameToFunc g_gles2_function_table[] = {
         "glDiscardBackbufferCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glDiscardBackbufferCHROMIUM),
     },
+    {
+        "glScheduleOverlayPlaneCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glScheduleOverlayPlaneCHROMIUM),
+    },
+    {
+        "glScheduleCALayerSharedStateCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(
+            glScheduleCALayerSharedStateCHROMIUM),
+    },
+    {
+        "glScheduleCALayerCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glScheduleCALayerCHROMIUM),
+    },
+    {
+        "glScheduleCALayerInUseQueryCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(
+            glScheduleCALayerInUseQueryCHROMIUM),
+    },
+    {
+        "glCommitOverlayPlanesCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glCommitOverlayPlanesCHROMIUM),
+    },
     {
         "glFlushDriverCachesCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glFlushDriverCachesCHROMIUM),
@@ -2951,6 +3079,10 @@ extern const NameToFunc g_gles2_function_table[] = {
         "glGetLastFlushIdCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glGetLastFlushIdCHROMIUM),
     },
+    {
+        "glScheduleDCLayerCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glScheduleDCLayerCHROMIUM),
+    },
     {
         "glSetActiveURLCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glSetActiveURLCHROMIUM),
@@ -2984,6 +3116,18 @@ extern const NameToFunc g_gles2_function_table[] = {
         "glGetFragDataIndexEXT",
         reinterpret_cast<GLES2FunctionPointer>(glGetFragDataIndexEXT),
     },
+    {
+        "glSwapBuffersWithBoundsCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glSwapBuffersWithBoundsCHROMIUM),
+    },
+    {
+        "glSetDrawRectangleCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glSetDrawRectangleCHROMIUM),
+    },
+    {
+        "glSetEnableDCLayersCHROMIUM",
+        reinterpret_cast<GLES2FunctionPointer>(glSetEnableDCLayersCHROMIUM),
+    },
     {
         "glInitializeDiscardableTextureCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(
diff --git gpu/command_buffer/client/gles2_cmd_helper_autogen.h gpu/command_buffer/client/gles2_cmd_helper_autogen.h
index 8b9959ed6067a..4e12ef5c2a3cc 100644
--- gpu/command_buffer/client/gles2_cmd_helper_autogen.h
+++ gpu/command_buffer/client/gles2_cmd_helper_autogen.h
@@ -2789,6 +2789,19 @@ void GetTranslatedShaderSourceANGLE(GLuint shader, uint32_t bucket_id) {
   }
 }
 
+void PostSubBufferCHROMIUM(GLuint64 swap_id,
+                           GLint x,
+                           GLint y,
+                           GLint width,
+                           GLint height,
+                           GLbitfield flags) {
+  gles2::cmds::PostSubBufferCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::PostSubBufferCHROMIUM>();
+  if (c) {
+    c->Init(swap_id, x, y, width, height, flags);
+  }
+}
+
 void CopyTextureCHROMIUM(GLuint source_id,
                          GLint source_level,
                          GLenum dest_target,
@@ -2978,6 +2991,75 @@ void DiscardBackbufferCHROMIUM() {
   }
 }
 
+void ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                  GLenum plane_transform,
+                                  GLuint overlay_texture_id,
+                                  GLint bounds_x,
+                                  GLint bounds_y,
+                                  GLint bounds_width,
+                                  GLint bounds_height,
+                                  GLfloat uv_x,
+                                  GLfloat uv_y,
+                                  GLfloat uv_width,
+                                  GLfloat uv_height,
+                                  GLboolean enable_blend,
+                                  GLuint gpu_fence_id) {
+  gles2::cmds::ScheduleOverlayPlaneCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::ScheduleOverlayPlaneCHROMIUM>();
+  if (c) {
+    c->Init(plane_z_order, plane_transform, overlay_texture_id, bounds_x,
+            bounds_y, bounds_width, bounds_height, uv_x, uv_y, uv_width,
+            uv_height, enable_blend, gpu_fence_id);
+  }
+}
+
+void ScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                        GLboolean is_clipped,
+                                        GLint sorting_context_id,
+                                        GLuint shm_id,
+                                        GLuint shm_offset) {
+  gles2::cmds::ScheduleCALayerSharedStateCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::ScheduleCALayerSharedStateCHROMIUM>();
+  if (c) {
+    c->Init(opacity, is_clipped, sorting_context_id, shm_id, shm_offset);
+  }
+}
+
+void ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                             GLuint background_color,
+                             GLuint edge_aa_mask,
+                             GLuint filter,
+                             GLuint shm_id,
+                             GLuint shm_offset) {
+  gles2::cmds::ScheduleCALayerCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::ScheduleCALayerCHROMIUM>();
+  if (c) {
+    c->Init(contents_texture_id, background_color, edge_aa_mask, filter, shm_id,
+            shm_offset);
+  }
+}
+
+void ScheduleCALayerInUseQueryCHROMIUMImmediate(GLsizei count,
+                                                const GLuint* textures) {
+  const uint32_t size =
+      gles2::cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate::ComputeSize(
+          count);
+  gles2::cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate* c =
+      GetImmediateCmdSpaceTotalSize<
+          gles2::cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate>(size);
+  if (c) {
+    c->Init(count, textures);
+  }
+}
+
+void CommitOverlayPlanesCHROMIUM(GLuint64 swap_id, GLbitfield flags) {
+  gles2::cmds::CommitOverlayPlanesCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::CommitOverlayPlanesCHROMIUM>();
+  if (c) {
+    c->Init(swap_id, flags);
+  }
+}
+
 void FlushDriverCachesCHROMIUM() {
   gles2::cmds::FlushDriverCachesCHROMIUM* c =
       GetCmdSpace<gles2::cmds::FlushDriverCachesCHROMIUM>();
@@ -2986,6 +3068,40 @@ void FlushDriverCachesCHROMIUM() {
   }
 }
 
+void ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                             GLuint texture_1,
+                             GLint z_order,
+                             GLint content_x,
+                             GLint content_y,
+                             GLint content_width,
+                             GLint content_height,
+                             GLint quad_x,
+                             GLint quad_y,
+                             GLint quad_width,
+                             GLint quad_height,
+                             GLfloat transform_c1r1,
+                             GLfloat transform_c2r1,
+                             GLfloat transform_c1r2,
+                             GLfloat transform_c2r2,
+                             GLfloat transform_tx,
+                             GLfloat transform_ty,
+                             GLboolean is_clipped,
+                             GLint clip_x,
+                             GLint clip_y,
+                             GLint clip_width,
+                             GLint clip_height,
+                             GLuint protected_video_type) {
+  gles2::cmds::ScheduleDCLayerCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::ScheduleDCLayerCHROMIUM>();
+  if (c) {
+    c->Init(texture_0, texture_1, z_order, content_x, content_y, content_width,
+            content_height, quad_x, quad_y, quad_width, quad_height,
+            transform_c1r1, transform_c2r1, transform_c1r2, transform_c2r2,
+            transform_tx, transform_ty, is_clipped, clip_x, clip_y, clip_width,
+            clip_height, protected_video_type);
+  }
+}
+
 void SetActiveURLCHROMIUM(GLuint url_bucket_id) {
   gles2::cmds::SetActiveURLCHROMIUM* c =
       GetCmdSpace<gles2::cmds::SetActiveURLCHROMIUM>();
@@ -3049,6 +3165,36 @@ void GetFragDataIndexEXT(GLuint program,
   }
 }
 
+void SwapBuffersWithBoundsCHROMIUMImmediate(GLuint64 swap_id,
+                                            GLsizei count,
+                                            const GLint* rects,
+                                            GLbitfield flags) {
+  const uint32_t size =
+      gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate::ComputeSize(count);
+  gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate* c =
+      GetImmediateCmdSpaceTotalSize<
+          gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate>(size);
+  if (c) {
+    c->Init(swap_id, count, rects, flags);
+  }
+}
+
+void SetDrawRectangleCHROMIUM(GLint x, GLint y, GLint width, GLint height) {
+  gles2::cmds::SetDrawRectangleCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::SetDrawRectangleCHROMIUM>();
+  if (c) {
+    c->Init(x, y, width, height);
+  }
+}
+
+void SetEnableDCLayersCHROMIUM(GLboolean enabled) {
+  gles2::cmds::SetEnableDCLayersCHROMIUM* c =
+      GetCmdSpace<gles2::cmds::SetEnableDCLayersCHROMIUM>();
+  if (c) {
+    c->Init(enabled);
+  }
+}
+
 void InitializeDiscardableTextureCHROMIUM(GLuint texture_id,
                                           uint32_t shm_id,
                                           uint32_t shm_offset) {
diff --git gpu/command_buffer/client/gles2_implementation.cc gpu/command_buffer/client/gles2_implementation.cc
index c034df27e0664..0acecd09c6564 100644
--- gpu/command_buffer/client/gles2_implementation.cc
+++ gpu/command_buffer/client/gles2_implementation.cc
@@ -391,7 +391,18 @@ void GLES2Implementation::OnGpuControlErrorMessage(const char* message,
 
 void GLES2Implementation::OnGpuControlSwapBuffersCompleted(
     const SwapBuffersCompleteParams& params,
-    gfx::GpuFenceHandle release_fence) {}
+    gfx::GpuFenceHandle release_fence) {
+  auto found = pending_swap_callbacks_.find(params.swap_response.swap_id);
+  if (found == pending_swap_callbacks_.end())
+    return;
+
+  // Erase the entry before running the callback to guard against the callback
+  // mutating the |pending_swap_callbacks_|.
+  auto callback = std::move(found->second);
+  pending_swap_callbacks_.erase(found);
+
+  std::move(callback).Run(params, std::move(release_fence));
+}
 
 void GLES2Implementation::OnGpuSwitched(
     gl::GpuPreference active_gpu_heuristic) {
@@ -439,7 +450,18 @@ void GLES2Implementation::CallDeferredErrorCallbacks() {
 
 void GLES2Implementation::OnSwapBufferPresented(
     uint64_t swap_id,
-    const gfx::PresentationFeedback& feedback) {}
+    const gfx::PresentationFeedback& feedback) {
+  auto found = pending_presentation_callbacks_.find(swap_id);
+  if (found == pending_presentation_callbacks_.end())
+    return;
+
+  // Erase the entry before running the callback to guard against the callback
+  // mutating the |pending_presentation_callbacks_|.
+  auto callback = std::move(found->second);
+  pending_presentation_callbacks_.erase(found);
+
+  std::move(callback).Run(feedback);
+}
 
 void GLES2Implementation::OnGpuControlReturnData(
     base::span<const uint8_t> data) {
@@ -1600,6 +1622,37 @@ void GLES2Implementation::SwapBuffers(uint64_t swap_id, GLbitfield flags) {
   }
 }
 
+void GLES2Implementation::SwapBuffersWithBoundsCHROMIUM(uint64_t swap_id,
+                                                        GLsizei count,
+                                                        const GLint* rects,
+                                                        GLbitfield flags) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glSwapBuffersWithBoundsCHROMIUM("
+                     << count << ", " << static_cast<const void*>(rects)
+                     << ")");
+  GPU_CLIENT_LOG_CODE_BLOCK({
+    for (GLsizei i = 0; i < count; ++i) {
+      GPU_CLIENT_LOG("  " << i << ": " << rects[0 + i * 4] << ", "
+                          << rects[1 + i * 4] << ", " << rects[2 + i * 4]
+                          << ", " << rects[3 + i * 4]);
+    }
+  });
+  if (count < 0) {
+    SetGLError(GL_INVALID_VALUE, "glSwapBuffersWithBoundsCHROMIUM",
+               "count < 0");
+    return;
+  }
+
+  // Same flow control as GLES2Implementation::SwapBuffers (see comments there).
+  swap_buffers_tokens_.push(helper_->InsertToken());
+  helper_->SwapBuffersWithBoundsCHROMIUMImmediate(swap_id, count, rects, flags);
+  helper_->CommandBufferHelper::Flush();
+  if (swap_buffers_tokens_.size() > kMaxSwapBuffers + 1) {
+    helper_->WaitForToken(swap_buffers_tokens_.front());
+    swap_buffers_tokens_.pop();
+  }
+}
+
 void GLES2Implementation::BindAttribLocation(GLuint program,
                                              GLuint index,
                                              const char* name) {
@@ -3213,6 +3266,18 @@ PixelStoreParams GLES2Implementation::GetUnpackParameters(Dimension dimension) {
   return params;
 }
 
+uint64_t GLES2Implementation::PrepareNextSwapId(
+    SwapCompletedCallback completion_callback,
+    PresentationCallback presentation_callback) {
+  uint64_t swap_id = swap_id_++;
+  pending_swap_callbacks_.emplace(swap_id, std::move(completion_callback));
+  if (!presentation_callback.is_null()) {
+    pending_presentation_callbacks_.emplace(swap_id,
+                                            std::move(presentation_callback));
+  }
+  return swap_id;
+}
+
 void GLES2Implementation::TexImage2D(GLenum target,
                                      GLint level,
                                      GLint internalformat,
@@ -5599,6 +5664,134 @@ GLenum GLES2Implementation::GetGraphicsResetStatusKHR() {
   return GL_NO_ERROR;
 }
 
+void GLES2Implementation::Swap(uint32_t flags,
+                               SwapCompletedCallback complete_callback,
+                               PresentationCallback presentation_callback) {
+  SwapBuffers(PrepareNextSwapId(std::move(complete_callback),
+                                std::move(presentation_callback)),
+              flags);
+}
+
+void GLES2Implementation::SwapWithBounds(
+    const std::vector<gfx::Rect>& rects,
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  std::vector<int> rects_data(rects.size() * 4);
+  for (size_t i = 0; i < rects.size(); ++i) {
+    rects_data[i * 4 + 0] = rects[i].x();
+    rects_data[i * 4 + 1] = rects[i].y();
+    rects_data[i * 4 + 2] = rects[i].width();
+    rects_data[i * 4 + 3] = rects[i].height();
+  }
+  SwapBuffersWithBoundsCHROMIUM(
+      PrepareNextSwapId(std::move(swap_completed),
+                        std::move(presentation_callback)),
+      rects.size(), rects_data.data(), flags);
+}
+
+void GLES2Implementation::PartialSwapBuffers(
+    const gfx::Rect& sub_buffer,
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  PostSubBufferCHROMIUM(PrepareNextSwapId(std::move(swap_completed),
+                                          std::move(presentation_callback)),
+                        sub_buffer.x(), sub_buffer.y(), sub_buffer.width(),
+                        sub_buffer.height(), flags);
+}
+
+void GLES2Implementation::CommitOverlayPlanes(
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  CommitOverlayPlanesCHROMIUM(
+      PrepareNextSwapId(std::move(swap_completed),
+                        std::move(presentation_callback)),
+      flags);
+}
+
+static GLenum GetGLESOverlayTransform(gfx::OverlayTransform plane_transform) {
+  switch (plane_transform) {
+    case gfx::OVERLAY_TRANSFORM_INVALID:
+      break;
+    case gfx::OVERLAY_TRANSFORM_NONE:
+      return GL_OVERLAY_TRANSFORM_NONE_CHROMIUM;
+    case gfx::OVERLAY_TRANSFORM_FLIP_HORIZONTAL:
+      return GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM;
+    case gfx::OVERLAY_TRANSFORM_FLIP_VERTICAL:
+      return GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM;
+    case gfx::OVERLAY_TRANSFORM_ROTATE_90:
+      return GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM;
+    case gfx::OVERLAY_TRANSFORM_ROTATE_180:
+      return GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM;
+    case gfx::OVERLAY_TRANSFORM_ROTATE_270:
+      return GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM;
+  }
+  NOTREACHED();
+  return GL_OVERLAY_TRANSFORM_NONE_CHROMIUM;
+}
+
+void GLES2Implementation::ScheduleOverlayPlane(
+    int plane_z_order,
+    gfx::OverlayTransform plane_transform,
+    unsigned overlay_texture_id,
+    const gfx::Rect& display_bounds,
+    const gfx::RectF& uv_rect,
+    bool enable_blend,
+    unsigned gpu_fence_id) {
+  ScheduleOverlayPlaneCHROMIUM(
+      plane_z_order, GetGLESOverlayTransform(plane_transform),
+      overlay_texture_id, display_bounds.x(), display_bounds.y(),
+      display_bounds.width(), display_bounds.height(), uv_rect.x(), uv_rect.y(),
+      uv_rect.width(), uv_rect.height(), enable_blend, gpu_fence_id);
+}
+
+void GLES2Implementation::ScheduleCALayerSharedStateCHROMIUM(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    const GLfloat* rounded_corner_bounds,
+    GLint sorting_context_id,
+    const GLfloat* transform) {
+  // 4 for clip_rect, 5 for rounded_corner_rect, 16 for transform.
+  uint32_t shm_size = 25 * sizeof(GLfloat);
+  ScopedTransferBufferPtr buffer(shm_size, helper_, transfer_buffer_);
+  if (!buffer.valid() || buffer.size() < shm_size) {
+    SetGLError(GL_OUT_OF_MEMORY, "GLES2::ScheduleCALayerSharedStateCHROMIUM",
+               "out of memory");
+    return;
+  }
+  GLfloat* mem = static_cast<GLfloat*>(buffer.address());
+  memcpy(mem + 0, clip_rect, 4 * sizeof(GLfloat));
+  memcpy(mem + 4, rounded_corner_bounds, 5 * sizeof(GLfloat));
+  memcpy(mem + 9, transform, 16 * sizeof(GLfloat));
+  helper_->ScheduleCALayerSharedStateCHROMIUM(opacity, is_clipped,
+                                              sorting_context_id,
+                                              buffer.shm_id(), buffer.offset());
+}
+
+void GLES2Implementation::ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                                                  const GLfloat* contents_rect,
+                                                  GLuint background_color,
+                                                  GLuint edge_aa_mask,
+                                                  const GLfloat* bounds_rect,
+                                                  GLuint filter) {
+  uint32_t shm_size = 8 * sizeof(GLfloat);
+  ScopedTransferBufferPtr buffer(shm_size, helper_, transfer_buffer_);
+  if (!buffer.valid() || buffer.size() < shm_size) {
+    SetGLError(GL_OUT_OF_MEMORY, "GLES2::ScheduleCALayerCHROMIUM",
+               "out of memory");
+    return;
+  }
+  GLfloat* mem = static_cast<GLfloat*>(buffer.address());
+  memcpy(mem + 0, contents_rect, 4 * sizeof(GLfloat));
+  memcpy(mem + 4, bounds_rect, 4 * sizeof(GLfloat));
+  helper_->ScheduleCALayerCHROMIUM(contents_texture_id, background_color,
+                                   edge_aa_mask, filter, buffer.shm_id(),
+                                   buffer.offset());
+}
+
 void GLES2Implementation::SetColorSpaceMetadataCHROMIUM(
     GLuint texture_id,
     GLcolorSpace color_space) {
@@ -5626,6 +5819,22 @@ void GLES2Implementation::SetColorSpaceMetadataCHROMIUM(
 #endif
 }
 
+void GLES2Implementation::CommitOverlayPlanesCHROMIUM(uint64_t swap_id,
+                                                      uint32_t flags) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] CommitOverlayPlanesCHROMIUM()");
+  TRACE_EVENT0("gpu", "GLES2::CommitOverlayPlanesCHROMIUM");
+
+  // Same flow control as GLES2Implementation::SwapBuffers (see comments there).
+  swap_buffers_tokens_.push(helper_->InsertToken());
+  helper_->CommitOverlayPlanesCHROMIUM(swap_id, flags);
+  helper_->CommandBufferHelper::Flush();
+  if (swap_buffers_tokens_.size() > kMaxSwapBuffers + 1) {
+    helper_->WaitForToken(swap_buffers_tokens_.front());
+    swap_buffers_tokens_.pop();
+  }
+}
+
 GLboolean GLES2Implementation::EnableFeatureCHROMIUM(const char* feature) {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glEnableFeatureCHROMIUM("
@@ -6218,6 +6427,28 @@ void GLES2Implementation::GetTransformFeedbackVaryingsCHROMIUM(GLuint program,
   memcpy(info, &result[0], result.size());
 }
 
+void GLES2Implementation::PostSubBufferCHROMIUM(uint64_t swap_id,
+                                                GLint x,
+                                                GLint y,
+                                                GLint width,
+                                                GLint height,
+                                                GLbitfield flags) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] PostSubBufferCHROMIUM(" << x
+                     << ", " << y << ", " << width << ", " << height << ")");
+  TRACE_EVENT2("gpu", "GLES2::PostSubBufferCHROMIUM", "width", width, "height",
+               height);
+
+  // Same flow control as GLES2Implementation::SwapBuffers (see comments there).
+  swap_buffers_tokens_.push(helper_->InsertToken());
+  helper_->PostSubBufferCHROMIUM(swap_id, x, y, width, height, flags);
+  helper_->CommandBufferHelper::Flush();
+  if (swap_buffers_tokens_.size() > kMaxSwapBuffers + 1) {
+    helper_->WaitForToken(swap_buffers_tokens_.front());
+    swap_buffers_tokens_.pop();
+  }
+}
+
 void GLES2Implementation::DeleteQueriesEXTHelper(GLsizei n,
                                                  const GLuint* queries) {
   IdAllocator* id_allocator = GetIdAllocator(IdNamespaces::kQueries);
diff --git gpu/command_buffer/client/gles2_implementation.h gpu/command_buffer/client/gles2_implementation.h
index 1910657bbed38..1d5cac8808ee9 100644
--- gpu/command_buffer/client/gles2_implementation.h
+++ gpu/command_buffer/client/gles2_implementation.h
@@ -110,6 +110,27 @@ class GLES2_IMPL_EXPORT GLES2Implementation : public GLES2Interface,
 
   // ContextSupport implementation.
   void SetAggressivelyFreeResources(bool aggressively_free_resources) override;
+  void Swap(uint32_t flags,
+            SwapCompletedCallback complete_callback,
+            PresentationCallback presentation_callback) override;
+  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                      uint32_t flags,
+                      SwapCompletedCallback swap_completed,
+                      PresentationCallback presentation_callback) override;
+  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
+                          uint32_t flags,
+                          SwapCompletedCallback swap_completed,
+                          PresentationCallback presentation_callback) override;
+  void CommitOverlayPlanes(uint32_t flags,
+                           SwapCompletedCallback swap_completed,
+                           PresentationCallback presentation_callback) override;
+  void ScheduleOverlayPlane(int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            unsigned overlay_texture_id,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& uv_rect,
+                            bool enable_blend,
+                            unsigned gpu_fence_id) override;
   uint64_t ShareGroupTracingGUID() const override;
   void SetErrorMessageCallback(
       base::RepeatingCallback<void(const char*, int32_t)> callback) override;
@@ -675,6 +696,9 @@ class GLES2_IMPL_EXPORT GLES2Implementation : public GLES2Interface,
 
   PixelStoreParams GetUnpackParameters(Dimension dimension);
 
+  uint64_t PrepareNextSwapId(SwapCompletedCallback complete_callback,
+                             PresentationCallback present_callback);
+
   GLES2Util util_;
   raw_ptr<GLES2CmdHelper> helper_;
   std::string last_error_;
@@ -831,6 +855,13 @@ class GLES2_IMPL_EXPORT GLES2Implementation : public GLES2Interface,
   // gl_strings, valid forever.
   std::vector<const char*> cached_extensions_;
 
+  // The next swap ID to send.
+  uint64_t swap_id_ = 0;
+  // A map of swap IDs to callbacks to run when that ID completes.
+  base::flat_map<uint64_t, SwapCompletedCallback> pending_swap_callbacks_;
+  base::flat_map<uint64_t, PresentationCallback>
+      pending_presentation_callbacks_;
+
   std::string last_active_url_;
 
   bool gpu_switched_ = false;
diff --git gpu/command_buffer/client/gles2_implementation_autogen.h gpu/command_buffer/client/gles2_implementation_autogen.h
index b43709080a618..41eae4ea90c1b 100644
--- gpu/command_buffer/client/gles2_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_autogen.h
@@ -1028,6 +1028,13 @@ void GetTranslatedShaderSourceANGLE(GLuint shader,
                                     GLsizei* length,
                                     char* source) override;
 
+void PostSubBufferCHROMIUM(GLuint64 swap_id,
+                           GLint x,
+                           GLint y,
+                           GLint width,
+                           GLint height,
+                           GLbitfield flags = 0) override;
+
 void CopyTextureCHROMIUM(GLuint source_id,
                          GLint source_level,
                          GLenum dest_target,
@@ -1105,10 +1112,68 @@ void DrawBuffersEXT(GLsizei count, const GLenum* bufs) override;
 
 void DiscardBackbufferCHROMIUM() override;
 
+void ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                  GLenum plane_transform,
+                                  GLuint overlay_texture_id,
+                                  GLint bounds_x,
+                                  GLint bounds_y,
+                                  GLint bounds_width,
+                                  GLint bounds_height,
+                                  GLfloat uv_x,
+                                  GLfloat uv_y,
+                                  GLfloat uv_width,
+                                  GLfloat uv_height,
+                                  GLboolean enable_blend,
+                                  GLuint gpu_fence_id) override;
+
+void ScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                        GLboolean is_clipped,
+                                        const GLfloat* clip_rect,
+                                        const GLfloat* rounded_corner_bounds,
+                                        GLint sorting_context_id,
+                                        const GLfloat* transform) override;
+
+void ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                             const GLfloat* contents_rect,
+                             GLuint background_color,
+                             GLuint edge_aa_mask,
+                             const GLfloat* bounds_rect,
+                             GLuint filter) override;
+
+void ScheduleCALayerInUseQueryCHROMIUM(GLsizei count,
+                                       const GLuint* textures) override;
+
+void CommitOverlayPlanesCHROMIUM(GLuint64 swap_id,
+                                 GLbitfield flags = 0) override;
+
 void FlushDriverCachesCHROMIUM() override;
 
 GLuint GetLastFlushIdCHROMIUM() override;
 
+void ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                             GLuint texture_1,
+                             GLint z_order,
+                             GLint content_x,
+                             GLint content_y,
+                             GLint content_width,
+                             GLint content_height,
+                             GLint quad_x,
+                             GLint quad_y,
+                             GLint quad_width,
+                             GLint quad_height,
+                             GLfloat transform_c1r1,
+                             GLfloat transform_c2r1,
+                             GLfloat transform_c1r2,
+                             GLfloat transform_c2r2,
+                             GLfloat transform_tx,
+                             GLfloat transform_ty,
+                             GLboolean is_clipped,
+                             GLint clip_x,
+                             GLint clip_y,
+                             GLint clip_width,
+                             GLint clip_height,
+                             GLuint protected_video_type) override;
+
 void SetActiveURLCHROMIUM(const char* url) override;
 
 void ContextVisibilityHintCHROMIUM(GLboolean visibility) override;
@@ -1130,6 +1195,18 @@ void BindFragDataLocationEXT(GLuint program,
 
 GLint GetFragDataIndexEXT(GLuint program, const char* name) override;
 
+void SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                   GLsizei count,
+                                   const GLint* rects,
+                                   GLbitfield flags = 0) override;
+
+void SetDrawRectangleCHROMIUM(GLint x,
+                              GLint y,
+                              GLint width,
+                              GLint height) override;
+
+void SetEnableDCLayersCHROMIUM(GLboolean enabled) override;
+
 void InitializeDiscardableTextureCHROMIUM(GLuint texture_id) override;
 
 void UnlockDiscardableTextureCHROMIUM(GLuint texture_id) override;
diff --git gpu/command_buffer/client/gles2_implementation_impl_autogen.h gpu/command_buffer/client/gles2_implementation_impl_autogen.h
index cf588a7fe64a1..c9ba4caf50b55 100644
--- gpu/command_buffer/client/gles2_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_impl_autogen.h
@@ -3381,6 +3381,57 @@ void GLES2Implementation::DiscardBackbufferCHROMIUM() {
   CheckGLError();
 }
 
+void GLES2Implementation::ScheduleOverlayPlaneCHROMIUM(
+    GLint plane_z_order,
+    GLenum plane_transform,
+    GLuint overlay_texture_id,
+    GLint bounds_x,
+    GLint bounds_y,
+    GLint bounds_width,
+    GLint bounds_height,
+    GLfloat uv_x,
+    GLfloat uv_y,
+    GLfloat uv_width,
+    GLfloat uv_height,
+    GLboolean enable_blend,
+    GLuint gpu_fence_id) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG(
+      "[" << GetLogPrefix() << "] glScheduleOverlayPlaneCHROMIUM("
+          << plane_z_order << ", " << GLES2Util::GetStringEnum(plane_transform)
+          << ", " << overlay_texture_id << ", " << bounds_x << ", " << bounds_y
+          << ", " << bounds_width << ", " << bounds_height << ", " << uv_x
+          << ", " << uv_y << ", " << uv_width << ", " << uv_height << ", "
+          << GLES2Util::GetStringBool(enable_blend) << ", " << gpu_fence_id
+          << ")");
+  helper_->ScheduleOverlayPlaneCHROMIUM(
+      plane_z_order, plane_transform, overlay_texture_id, bounds_x, bounds_y,
+      bounds_width, bounds_height, uv_x, uv_y, uv_width, uv_height,
+      enable_blend, gpu_fence_id);
+  CheckGLError();
+}
+
+void GLES2Implementation::ScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei count,
+    const GLuint* textures) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix()
+                     << "] glScheduleCALayerInUseQueryCHROMIUM(" << count
+                     << ", " << static_cast<const void*>(textures) << ")");
+  GPU_CLIENT_LOG_CODE_BLOCK({
+    for (GLsizei i = 0; i < count; ++i) {
+      GPU_CLIENT_LOG("  " << i << ": " << textures[0 + i * 1]);
+    }
+  });
+  if (count < 0) {
+    SetGLError(GL_INVALID_VALUE, "glScheduleCALayerInUseQueryCHROMIUM",
+               "count < 0");
+    return;
+  }
+  helper_->ScheduleCALayerInUseQueryCHROMIUMImmediate(count, textures);
+  CheckGLError();
+}
+
 void GLES2Implementation::FlushDriverCachesCHROMIUM() {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glFlushDriverCachesCHROMIUM("
@@ -3389,6 +3440,50 @@ void GLES2Implementation::FlushDriverCachesCHROMIUM() {
   CheckGLError();
 }
 
+void GLES2Implementation::ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                                  GLuint texture_1,
+                                                  GLint z_order,
+                                                  GLint content_x,
+                                                  GLint content_y,
+                                                  GLint content_width,
+                                                  GLint content_height,
+                                                  GLint quad_x,
+                                                  GLint quad_y,
+                                                  GLint quad_width,
+                                                  GLint quad_height,
+                                                  GLfloat transform_c1r1,
+                                                  GLfloat transform_c2r1,
+                                                  GLfloat transform_c1r2,
+                                                  GLfloat transform_c2r2,
+                                                  GLfloat transform_tx,
+                                                  GLfloat transform_ty,
+                                                  GLboolean is_clipped,
+                                                  GLint clip_x,
+                                                  GLint clip_y,
+                                                  GLint clip_width,
+                                                  GLint clip_height,
+                                                  GLuint protected_video_type) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG(
+      "[" << GetLogPrefix() << "] glScheduleDCLayerCHROMIUM(" << texture_0
+          << ", " << texture_1 << ", " << z_order << ", " << content_x << ", "
+          << content_y << ", " << content_width << ", " << content_height
+          << ", " << quad_x << ", " << quad_y << ", " << quad_width << ", "
+          << quad_height << ", " << transform_c1r1 << ", " << transform_c2r1
+          << ", " << transform_c1r2 << ", " << transform_c2r2 << ", "
+          << transform_tx << ", " << transform_ty << ", "
+          << GLES2Util::GetStringBool(is_clipped) << ", " << clip_x << ", "
+          << clip_y << ", " << clip_width << ", " << clip_height << ", "
+          << protected_video_type << ")");
+  helper_->ScheduleDCLayerCHROMIUM(
+      texture_0, texture_1, z_order, content_x, content_y, content_width,
+      content_height, quad_x, quad_y, quad_width, quad_height, transform_c1r1,
+      transform_c2r1, transform_c1r2, transform_c2r2, transform_tx,
+      transform_ty, is_clipped, clip_x, clip_y, clip_width, clip_height,
+      protected_video_type);
+  CheckGLError();
+}
+
 void GLES2Implementation::ContextVisibilityHintCHROMIUM(GLboolean visibility) {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glContextVisibilityHintCHROMIUM("
@@ -3415,6 +3510,25 @@ void GLES2Implementation::BlendBarrierKHR() {
   CheckGLError();
 }
 
+void GLES2Implementation::SetDrawRectangleCHROMIUM(GLint x,
+                                                   GLint y,
+                                                   GLint width,
+                                                   GLint height) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glSetDrawRectangleCHROMIUM(" << x
+                     << ", " << y << ", " << width << ", " << height << ")");
+  helper_->SetDrawRectangleCHROMIUM(x, y, width, height);
+  CheckGLError();
+}
+
+void GLES2Implementation::SetEnableDCLayersCHROMIUM(GLboolean enabled) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glSetEnableDCLayersCHROMIUM("
+                     << GLES2Util::GetStringBool(enabled) << ")");
+  helper_->SetEnableDCLayersCHROMIUM(enabled);
+  CheckGLError();
+}
+
 void GLES2Implementation::TexStorage2DImageCHROMIUM(GLenum target,
                                                     GLenum internalFormat,
                                                     GLenum bufferUsage,
diff --git gpu/command_buffer/client/gles2_implementation_unittest_autogen.h gpu/command_buffer/client/gles2_implementation_unittest_autogen.h
index 030dbb73074b9..e8e14aeda1670 100644
--- gpu/command_buffer/client/gles2_implementation_unittest_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_unittest_autogen.h
@@ -2933,6 +2933,24 @@ TEST_F(GLES2ImplementationTest, DiscardBackbufferCHROMIUM) {
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
 }
 
+TEST_F(GLES2ImplementationTest, ScheduleCALayerInUseQueryCHROMIUM) {
+  GLuint data[1][1] = {{0}};
+  struct Cmds {
+    cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate cmd;
+    GLuint data[1][1];
+  };
+
+  Cmds expected;
+  for (int ii = 0; ii < 1; ++ii) {
+    for (int jj = 0; jj < 1; ++jj) {
+      data[ii][jj] = static_cast<GLuint>(ii * 1 + jj);
+    }
+  }
+  expected.cmd.Init(1, &data[0][0]);
+  gl_->ScheduleCALayerInUseQueryCHROMIUM(1, &data[0][0]);
+  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
+}
+
 TEST_F(GLES2ImplementationTest, FlushDriverCachesCHROMIUM) {
   struct Cmds {
     cmds::FlushDriverCachesCHROMIUM cmd;
@@ -2944,6 +2962,19 @@ TEST_F(GLES2ImplementationTest, FlushDriverCachesCHROMIUM) {
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
 }
 
+TEST_F(GLES2ImplementationTest, ScheduleDCLayerCHROMIUM) {
+  struct Cmds {
+    cmds::ScheduleDCLayerCHROMIUM cmd;
+  };
+  Cmds expected;
+  expected.cmd.Init(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+                    true, 19, 20, 21, 22, 23);
+
+  gl_->ScheduleDCLayerCHROMIUM(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+                               15, 16, 17, true, 19, 20, 21, 22, 23);
+  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
+}
+
 TEST_F(GLES2ImplementationTest, CoverageModulationCHROMIUM) {
   struct Cmds {
     cmds::CoverageModulationCHROMIUM cmd;
@@ -2955,6 +2986,28 @@ TEST_F(GLES2ImplementationTest, CoverageModulationCHROMIUM) {
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
 }
 
+TEST_F(GLES2ImplementationTest, SetDrawRectangleCHROMIUM) {
+  struct Cmds {
+    cmds::SetDrawRectangleCHROMIUM cmd;
+  };
+  Cmds expected;
+  expected.cmd.Init(1, 2, 3, 4);
+
+  gl_->SetDrawRectangleCHROMIUM(1, 2, 3, 4);
+  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
+}
+
+TEST_F(GLES2ImplementationTest, SetEnableDCLayersCHROMIUM) {
+  struct Cmds {
+    cmds::SetEnableDCLayersCHROMIUM cmd;
+  };
+  Cmds expected;
+  expected.cmd.Init(true);
+
+  gl_->SetEnableDCLayersCHROMIUM(true);
+  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
+}
+
 TEST_F(GLES2ImplementationTest, TexStorage2DImageCHROMIUM) {
   struct Cmds {
     cmds::TexStorage2DImageCHROMIUM cmd;
diff --git gpu/command_buffer/client/gles2_interface_autogen.h gpu/command_buffer/client/gles2_interface_autogen.h
index 145c3089fd015..c67d45bb446d7 100644
--- gpu/command_buffer/client/gles2_interface_autogen.h
+++ gpu/command_buffer/client/gles2_interface_autogen.h
@@ -762,6 +762,12 @@ virtual void GetTranslatedShaderSourceANGLE(GLuint shader,
                                             GLsizei bufsize,
                                             GLsizei* length,
                                             char* source) = 0;
+virtual void PostSubBufferCHROMIUM(GLuint64 swap_id,
+                                   GLint x,
+                                   GLint y,
+                                   GLint width,
+                                   GLint height,
+                                   GLbitfield flags = 0) = 0;
 virtual void CopyTextureCHROMIUM(GLuint source_id,
                                  GLint source_level,
                                  GLenum dest_target,
@@ -823,8 +829,61 @@ virtual void DiscardFramebufferEXT(GLenum target,
 virtual void LoseContextCHROMIUM(GLenum current, GLenum other) = 0;
 virtual void DrawBuffersEXT(GLsizei count, const GLenum* bufs) = 0;
 virtual void DiscardBackbufferCHROMIUM() = 0;
+virtual void ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                          GLenum plane_transform,
+                                          GLuint overlay_texture_id,
+                                          GLint bounds_x,
+                                          GLint bounds_y,
+                                          GLint bounds_width,
+                                          GLint bounds_height,
+                                          GLfloat uv_x,
+                                          GLfloat uv_y,
+                                          GLfloat uv_width,
+                                          GLfloat uv_height,
+                                          GLboolean enable_blend,
+                                          GLuint gpu_fence_id) = 0;
+virtual void ScheduleCALayerSharedStateCHROMIUM(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    const GLfloat* rounded_corner_bounds,
+    GLint sorting_context_id,
+    const GLfloat* transform) = 0;
+virtual void ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                                     const GLfloat* contents_rect,
+                                     GLuint background_color,
+                                     GLuint edge_aa_mask,
+                                     const GLfloat* bounds_rect,
+                                     GLuint filter) = 0;
+virtual void ScheduleCALayerInUseQueryCHROMIUM(GLsizei count,
+                                               const GLuint* textures) = 0;
+virtual void CommitOverlayPlanesCHROMIUM(GLuint64 swap_id,
+                                         GLbitfield flags = 0) = 0;
 virtual void FlushDriverCachesCHROMIUM() = 0;
 virtual GLuint GetLastFlushIdCHROMIUM() = 0;
+virtual void ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                     GLuint texture_1,
+                                     GLint z_order,
+                                     GLint content_x,
+                                     GLint content_y,
+                                     GLint content_width,
+                                     GLint content_height,
+                                     GLint quad_x,
+                                     GLint quad_y,
+                                     GLint quad_width,
+                                     GLint quad_height,
+                                     GLfloat transform_c1r1,
+                                     GLfloat transform_c2r1,
+                                     GLfloat transform_c1r2,
+                                     GLfloat transform_c2r2,
+                                     GLfloat transform_tx,
+                                     GLfloat transform_ty,
+                                     GLboolean is_clipped,
+                                     GLint clip_x,
+                                     GLint clip_y,
+                                     GLint clip_width,
+                                     GLint clip_height,
+                                     GLuint protected_video_type) = 0;
 virtual void SetActiveURLCHROMIUM(const char* url) = 0;
 virtual void ContextVisibilityHintCHROMIUM(GLboolean visibility) = 0;
 virtual void CoverageModulationCHROMIUM(GLenum components) = 0;
@@ -838,6 +897,15 @@ virtual void BindFragDataLocationEXT(GLuint program,
                                      GLuint colorNumber,
                                      const char* name) = 0;
 virtual GLint GetFragDataIndexEXT(GLuint program, const char* name) = 0;
+virtual void SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                           GLsizei count,
+                                           const GLint* rects,
+                                           GLbitfield flags = 0) = 0;
+virtual void SetDrawRectangleCHROMIUM(GLint x,
+                                      GLint y,
+                                      GLint width,
+                                      GLint height) = 0;
+virtual void SetEnableDCLayersCHROMIUM(GLboolean enabled) = 0;
 virtual void InitializeDiscardableTextureCHROMIUM(GLuint texture_id) = 0;
 virtual void UnlockDiscardableTextureCHROMIUM(GLuint texture_id) = 0;
 virtual bool LockDiscardableTextureCHROMIUM(GLuint texture_id) = 0;
diff --git gpu/command_buffer/client/gles2_interface_stub_autogen.h gpu/command_buffer/client/gles2_interface_stub_autogen.h
index 241c05ac9dd62..13e2ae9870fc2 100644
--- gpu/command_buffer/client/gles2_interface_stub_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_autogen.h
@@ -738,6 +738,12 @@ void GetTranslatedShaderSourceANGLE(GLuint shader,
                                     GLsizei bufsize,
                                     GLsizei* length,
                                     char* source) override;
+void PostSubBufferCHROMIUM(GLuint64 swap_id,
+                           GLint x,
+                           GLint y,
+                           GLint width,
+                           GLint height,
+                           GLbitfield flags) override;
 void CopyTextureCHROMIUM(GLuint source_id,
                          GLint source_level,
                          GLenum dest_target,
@@ -799,8 +805,59 @@ void DiscardFramebufferEXT(GLenum target,
 void LoseContextCHROMIUM(GLenum current, GLenum other) override;
 void DrawBuffersEXT(GLsizei count, const GLenum* bufs) override;
 void DiscardBackbufferCHROMIUM() override;
+void ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                  GLenum plane_transform,
+                                  GLuint overlay_texture_id,
+                                  GLint bounds_x,
+                                  GLint bounds_y,
+                                  GLint bounds_width,
+                                  GLint bounds_height,
+                                  GLfloat uv_x,
+                                  GLfloat uv_y,
+                                  GLfloat uv_width,
+                                  GLfloat uv_height,
+                                  GLboolean enable_blend,
+                                  GLuint gpu_fence_id) override;
+void ScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                        GLboolean is_clipped,
+                                        const GLfloat* clip_rect,
+                                        const GLfloat* rounded_corner_bounds,
+                                        GLint sorting_context_id,
+                                        const GLfloat* transform) override;
+void ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                             const GLfloat* contents_rect,
+                             GLuint background_color,
+                             GLuint edge_aa_mask,
+                             const GLfloat* bounds_rect,
+                             GLuint filter) override;
+void ScheduleCALayerInUseQueryCHROMIUM(GLsizei count,
+                                       const GLuint* textures) override;
+void CommitOverlayPlanesCHROMIUM(GLuint64 swap_id, GLbitfield flags) override;
 void FlushDriverCachesCHROMIUM() override;
 GLuint GetLastFlushIdCHROMIUM() override;
+void ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                             GLuint texture_1,
+                             GLint z_order,
+                             GLint content_x,
+                             GLint content_y,
+                             GLint content_width,
+                             GLint content_height,
+                             GLint quad_x,
+                             GLint quad_y,
+                             GLint quad_width,
+                             GLint quad_height,
+                             GLfloat transform_c1r1,
+                             GLfloat transform_c2r1,
+                             GLfloat transform_c1r2,
+                             GLfloat transform_c2r2,
+                             GLfloat transform_tx,
+                             GLfloat transform_ty,
+                             GLboolean is_clipped,
+                             GLint clip_x,
+                             GLint clip_y,
+                             GLint clip_width,
+                             GLint clip_height,
+                             GLuint protected_video_type) override;
 void SetActiveURLCHROMIUM(const char* url) override;
 void ContextVisibilityHintCHROMIUM(GLboolean visibility) override;
 void CoverageModulationCHROMIUM(GLenum components) override;
@@ -814,6 +871,15 @@ void BindFragDataLocationEXT(GLuint program,
                              GLuint colorNumber,
                              const char* name) override;
 GLint GetFragDataIndexEXT(GLuint program, const char* name) override;
+void SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                   GLsizei count,
+                                   const GLint* rects,
+                                   GLbitfield flags) override;
+void SetDrawRectangleCHROMIUM(GLint x,
+                              GLint y,
+                              GLint width,
+                              GLint height) override;
+void SetEnableDCLayersCHROMIUM(GLboolean enabled) override;
 void InitializeDiscardableTextureCHROMIUM(GLuint texture_id) override;
 void UnlockDiscardableTextureCHROMIUM(GLuint texture_id) override;
 bool LockDiscardableTextureCHROMIUM(GLuint texture_id) override;
diff --git gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
index fdac5eff878b6..3d2076137b0b1 100644
--- gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
@@ -996,6 +996,12 @@ void GLES2InterfaceStub::GetTranslatedShaderSourceANGLE(GLuint /* shader */,
                                                         GLsizei /* bufsize */,
                                                         GLsizei* /* length */,
                                                         char* /* source */) {}
+void GLES2InterfaceStub::PostSubBufferCHROMIUM(GLuint64 /* swap_id */,
+                                               GLint /* x */,
+                                               GLint /* y */,
+                                               GLint /* width */,
+                                               GLint /* height */,
+                                               GLbitfield /* flags */) {}
 void GLES2InterfaceStub::CopyTextureCHROMIUM(
     GLuint /* source_id */,
     GLint /* source_level */,
@@ -1068,10 +1074,67 @@ void GLES2InterfaceStub::LoseContextCHROMIUM(GLenum /* current */,
 void GLES2InterfaceStub::DrawBuffersEXT(GLsizei /* count */,
                                         const GLenum* /* bufs */) {}
 void GLES2InterfaceStub::DiscardBackbufferCHROMIUM() {}
+void GLES2InterfaceStub::ScheduleOverlayPlaneCHROMIUM(
+    GLint /* plane_z_order */,
+    GLenum /* plane_transform */,
+    GLuint /* overlay_texture_id */,
+    GLint /* bounds_x */,
+    GLint /* bounds_y */,
+    GLint /* bounds_width */,
+    GLint /* bounds_height */,
+    GLfloat /* uv_x */,
+    GLfloat /* uv_y */,
+    GLfloat /* uv_width */,
+    GLfloat /* uv_height */,
+    GLboolean /* enable_blend */,
+    GLuint /* gpu_fence_id */) {}
+void GLES2InterfaceStub::ScheduleCALayerSharedStateCHROMIUM(
+    GLfloat /* opacity */,
+    GLboolean /* is_clipped */,
+    const GLfloat* /* clip_rect */,
+    const GLfloat* /* rounded_corner_bounds */,
+    GLint /* sorting_context_id */,
+    const GLfloat* /* transform */) {}
+void GLES2InterfaceStub::ScheduleCALayerCHROMIUM(
+    GLuint /* contents_texture_id */,
+    const GLfloat* /* contents_rect */,
+    GLuint /* background_color */,
+    GLuint /* edge_aa_mask */,
+    const GLfloat* /* bounds_rect */,
+    GLuint /* filter */) {}
+void GLES2InterfaceStub::ScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei /* count */,
+    const GLuint* /* textures */) {}
+void GLES2InterfaceStub::CommitOverlayPlanesCHROMIUM(GLuint64 /* swap_id */,
+                                                     GLbitfield /* flags */) {}
 void GLES2InterfaceStub::FlushDriverCachesCHROMIUM() {}
 GLuint GLES2InterfaceStub::GetLastFlushIdCHROMIUM() {
   return 0;
 }
+void GLES2InterfaceStub::ScheduleDCLayerCHROMIUM(
+    GLuint /* texture_0 */,
+    GLuint /* texture_1 */,
+    GLint /* z_order */,
+    GLint /* content_x */,
+    GLint /* content_y */,
+    GLint /* content_width */,
+    GLint /* content_height */,
+    GLint /* quad_x */,
+    GLint /* quad_y */,
+    GLint /* quad_width */,
+    GLint /* quad_height */,
+    GLfloat /* transform_c1r1 */,
+    GLfloat /* transform_c2r1 */,
+    GLfloat /* transform_c1r2 */,
+    GLfloat /* transform_c2r2 */,
+    GLfloat /* transform_tx */,
+    GLfloat /* transform_ty */,
+    GLboolean /* is_clipped */,
+    GLint /* clip_x */,
+    GLint /* clip_y */,
+    GLint /* clip_width */,
+    GLint /* clip_height */,
+    GLuint /* protected_video_type */) {}
 void GLES2InterfaceStub::SetActiveURLCHROMIUM(const char* /* url */) {}
 void GLES2InterfaceStub::ContextVisibilityHintCHROMIUM(
     GLboolean /* visibility */) {}
@@ -1092,6 +1155,16 @@ GLint GLES2InterfaceStub::GetFragDataIndexEXT(GLuint /* program */,
                                               const char* /* name */) {
   return 0;
 }
+void GLES2InterfaceStub::SwapBuffersWithBoundsCHROMIUM(GLuint64 /* swap_id */,
+                                                       GLsizei /* count */,
+                                                       const GLint* /* rects */,
+                                                       GLbitfield /* flags */) {
+}
+void GLES2InterfaceStub::SetDrawRectangleCHROMIUM(GLint /* x */,
+                                                  GLint /* y */,
+                                                  GLint /* width */,
+                                                  GLint /* height */) {}
+void GLES2InterfaceStub::SetEnableDCLayersCHROMIUM(GLboolean /* enabled */) {}
 void GLES2InterfaceStub::InitializeDiscardableTextureCHROMIUM(
     GLuint /* texture_id */) {}
 void GLES2InterfaceStub::UnlockDiscardableTextureCHROMIUM(
diff --git gpu/command_buffer/client/gles2_trace_implementation_autogen.h gpu/command_buffer/client/gles2_trace_implementation_autogen.h
index 3b61139163921..48d89fb36426b 100644
--- gpu/command_buffer/client/gles2_trace_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_autogen.h
@@ -738,6 +738,12 @@ void GetTranslatedShaderSourceANGLE(GLuint shader,
                                     GLsizei bufsize,
                                     GLsizei* length,
                                     char* source) override;
+void PostSubBufferCHROMIUM(GLuint64 swap_id,
+                           GLint x,
+                           GLint y,
+                           GLint width,
+                           GLint height,
+                           GLbitfield flags) override;
 void CopyTextureCHROMIUM(GLuint source_id,
                          GLint source_level,
                          GLenum dest_target,
@@ -799,8 +805,59 @@ void DiscardFramebufferEXT(GLenum target,
 void LoseContextCHROMIUM(GLenum current, GLenum other) override;
 void DrawBuffersEXT(GLsizei count, const GLenum* bufs) override;
 void DiscardBackbufferCHROMIUM() override;
+void ScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                  GLenum plane_transform,
+                                  GLuint overlay_texture_id,
+                                  GLint bounds_x,
+                                  GLint bounds_y,
+                                  GLint bounds_width,
+                                  GLint bounds_height,
+                                  GLfloat uv_x,
+                                  GLfloat uv_y,
+                                  GLfloat uv_width,
+                                  GLfloat uv_height,
+                                  GLboolean enable_blend,
+                                  GLuint gpu_fence_id) override;
+void ScheduleCALayerSharedStateCHROMIUM(GLfloat opacity,
+                                        GLboolean is_clipped,
+                                        const GLfloat* clip_rect,
+                                        const GLfloat* rounded_corner_bounds,
+                                        GLint sorting_context_id,
+                                        const GLfloat* transform) override;
+void ScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                             const GLfloat* contents_rect,
+                             GLuint background_color,
+                             GLuint edge_aa_mask,
+                             const GLfloat* bounds_rect,
+                             GLuint filter) override;
+void ScheduleCALayerInUseQueryCHROMIUM(GLsizei count,
+                                       const GLuint* textures) override;
+void CommitOverlayPlanesCHROMIUM(GLuint64 swap_id, GLbitfield flags) override;
 void FlushDriverCachesCHROMIUM() override;
 GLuint GetLastFlushIdCHROMIUM() override;
+void ScheduleDCLayerCHROMIUM(GLuint texture_0,
+                             GLuint texture_1,
+                             GLint z_order,
+                             GLint content_x,
+                             GLint content_y,
+                             GLint content_width,
+                             GLint content_height,
+                             GLint quad_x,
+                             GLint quad_y,
+                             GLint quad_width,
+                             GLint quad_height,
+                             GLfloat transform_c1r1,
+                             GLfloat transform_c2r1,
+                             GLfloat transform_c1r2,
+                             GLfloat transform_c2r2,
+                             GLfloat transform_tx,
+                             GLfloat transform_ty,
+                             GLboolean is_clipped,
+                             GLint clip_x,
+                             GLint clip_y,
+                             GLint clip_width,
+                             GLint clip_height,
+                             GLuint protected_video_type) override;
 void SetActiveURLCHROMIUM(const char* url) override;
 void ContextVisibilityHintCHROMIUM(GLboolean visibility) override;
 void CoverageModulationCHROMIUM(GLenum components) override;
@@ -814,6 +871,15 @@ void BindFragDataLocationEXT(GLuint program,
                              GLuint colorNumber,
                              const char* name) override;
 GLint GetFragDataIndexEXT(GLuint program, const char* name) override;
+void SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                   GLsizei count,
+                                   const GLint* rects,
+                                   GLbitfield flags) override;
+void SetDrawRectangleCHROMIUM(GLint x,
+                              GLint y,
+                              GLint width,
+                              GLint height) override;
+void SetEnableDCLayersCHROMIUM(GLboolean enabled) override;
 void InitializeDiscardableTextureCHROMIUM(GLuint texture_id) override;
 void UnlockDiscardableTextureCHROMIUM(GLuint texture_id) override;
 bool LockDiscardableTextureCHROMIUM(GLuint texture_id) override;
diff --git gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
index 4bbb85a11bec3..df3c0033857b8 100644
--- gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
@@ -2106,6 +2106,16 @@ void GLES2TraceImplementation::GetTranslatedShaderSourceANGLE(GLuint shader,
   gl_->GetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
 }
 
+void GLES2TraceImplementation::PostSubBufferCHROMIUM(GLuint64 swap_id,
+                                                     GLint x,
+                                                     GLint y,
+                                                     GLint width,
+                                                     GLint height,
+                                                     GLbitfield flags) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::PostSubBufferCHROMIUM");
+  gl_->PostSubBufferCHROMIUM(swap_id, x, y, width, height, flags);
+}
+
 void GLES2TraceImplementation::CopyTextureCHROMIUM(
     GLuint source_id,
     GLint source_level,
@@ -2253,6 +2263,70 @@ void GLES2TraceImplementation::DiscardBackbufferCHROMIUM() {
   gl_->DiscardBackbufferCHROMIUM();
 }
 
+void GLES2TraceImplementation::ScheduleOverlayPlaneCHROMIUM(
+    GLint plane_z_order,
+    GLenum plane_transform,
+    GLuint overlay_texture_id,
+    GLint bounds_x,
+    GLint bounds_y,
+    GLint bounds_width,
+    GLint bounds_height,
+    GLfloat uv_x,
+    GLfloat uv_y,
+    GLfloat uv_width,
+    GLfloat uv_height,
+    GLboolean enable_blend,
+    GLuint gpu_fence_id) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
+                                "GLES2Trace::ScheduleOverlayPlaneCHROMIUM");
+  gl_->ScheduleOverlayPlaneCHROMIUM(
+      plane_z_order, plane_transform, overlay_texture_id, bounds_x, bounds_y,
+      bounds_width, bounds_height, uv_x, uv_y, uv_width, uv_height,
+      enable_blend, gpu_fence_id);
+}
+
+void GLES2TraceImplementation::ScheduleCALayerSharedStateCHROMIUM(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    const GLfloat* rounded_corner_bounds,
+    GLint sorting_context_id,
+    const GLfloat* transform) {
+  TRACE_EVENT_BINARY_EFFICIENT0(
+      "gpu", "GLES2Trace::ScheduleCALayerSharedStateCHROMIUM");
+  gl_->ScheduleCALayerSharedStateCHROMIUM(opacity, is_clipped, clip_rect,
+                                          rounded_corner_bounds,
+                                          sorting_context_id, transform);
+}
+
+void GLES2TraceImplementation::ScheduleCALayerCHROMIUM(
+    GLuint contents_texture_id,
+    const GLfloat* contents_rect,
+    GLuint background_color,
+    GLuint edge_aa_mask,
+    const GLfloat* bounds_rect,
+    GLuint filter) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::ScheduleCALayerCHROMIUM");
+  gl_->ScheduleCALayerCHROMIUM(contents_texture_id, contents_rect,
+                               background_color, edge_aa_mask, bounds_rect,
+                               filter);
+}
+
+void GLES2TraceImplementation::ScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei count,
+    const GLuint* textures) {
+  TRACE_EVENT_BINARY_EFFICIENT0(
+      "gpu", "GLES2Trace::ScheduleCALayerInUseQueryCHROMIUM");
+  gl_->ScheduleCALayerInUseQueryCHROMIUM(count, textures);
+}
+
+void GLES2TraceImplementation::CommitOverlayPlanesCHROMIUM(GLuint64 swap_id,
+                                                           GLbitfield flags) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
+                                "GLES2Trace::CommitOverlayPlanesCHROMIUM");
+  gl_->CommitOverlayPlanesCHROMIUM(swap_id, flags);
+}
+
 void GLES2TraceImplementation::FlushDriverCachesCHROMIUM() {
   TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::FlushDriverCachesCHROMIUM");
   gl_->FlushDriverCachesCHROMIUM();
@@ -2263,6 +2337,39 @@ GLuint GLES2TraceImplementation::GetLastFlushIdCHROMIUM() {
   return gl_->GetLastFlushIdCHROMIUM();
 }
 
+void GLES2TraceImplementation::ScheduleDCLayerCHROMIUM(
+    GLuint texture_0,
+    GLuint texture_1,
+    GLint z_order,
+    GLint content_x,
+    GLint content_y,
+    GLint content_width,
+    GLint content_height,
+    GLint quad_x,
+    GLint quad_y,
+    GLint quad_width,
+    GLint quad_height,
+    GLfloat transform_c1r1,
+    GLfloat transform_c2r1,
+    GLfloat transform_c1r2,
+    GLfloat transform_c2r2,
+    GLfloat transform_tx,
+    GLfloat transform_ty,
+    GLboolean is_clipped,
+    GLint clip_x,
+    GLint clip_y,
+    GLint clip_width,
+    GLint clip_height,
+    GLuint protected_video_type) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::ScheduleDCLayerCHROMIUM");
+  gl_->ScheduleDCLayerCHROMIUM(
+      texture_0, texture_1, z_order, content_x, content_y, content_width,
+      content_height, quad_x, quad_y, quad_width, quad_height, transform_c1r1,
+      transform_c2r1, transform_c1r2, transform_c2r2, transform_tx,
+      transform_ty, is_clipped, clip_x, clip_y, clip_width, clip_height,
+      protected_video_type);
+}
+
 void GLES2TraceImplementation::SetActiveURLCHROMIUM(const char* url) {
   TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::SetActiveURLCHROMIUM");
   gl_->SetActiveURLCHROMIUM(url);
@@ -2314,6 +2421,28 @@ GLint GLES2TraceImplementation::GetFragDataIndexEXT(GLuint program,
   return gl_->GetFragDataIndexEXT(program, name);
 }
 
+void GLES2TraceImplementation::SwapBuffersWithBoundsCHROMIUM(GLuint64 swap_id,
+                                                             GLsizei count,
+                                                             const GLint* rects,
+                                                             GLbitfield flags) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
+                                "GLES2Trace::SwapBuffersWithBoundsCHROMIUM");
+  gl_->SwapBuffersWithBoundsCHROMIUM(swap_id, count, rects, flags);
+}
+
+void GLES2TraceImplementation::SetDrawRectangleCHROMIUM(GLint x,
+                                                        GLint y,
+                                                        GLint width,
+                                                        GLint height) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::SetDrawRectangleCHROMIUM");
+  gl_->SetDrawRectangleCHROMIUM(x, y, width, height);
+}
+
+void GLES2TraceImplementation::SetEnableDCLayersCHROMIUM(GLboolean enabled) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::SetEnableDCLayersCHROMIUM");
+  gl_->SetEnableDCLayersCHROMIUM(enabled);
+}
+
 void GLES2TraceImplementation::InitializeDiscardableTextureCHROMIUM(
     GLuint texture_id) {
   TRACE_EVENT_BINARY_EFFICIENT0(
diff --git gpu/command_buffer/client/gpu_control.h gpu/command_buffer/client/gpu_control.h
index eadc59239d895..9d46af7ed8a8c 100644
--- gpu/command_buffer/client/gpu_control.h
+++ gpu/command_buffer/client/gpu_control.h
@@ -108,6 +108,14 @@ class GPU_EXPORT GpuControl {
   // channel as the wait command guarantee that the fence sync will be enqueued
   // first so does not need to be flushed.
   virtual bool CanWaitUnverifiedSyncToken(const SyncToken& sync_token) = 0;
+
+  // Notifies the onscreen surface of the display transform applied to the swaps
+  // from the client.
+  virtual void SetDisplayTransform(gfx::OverlayTransform transform) = 0;
+
+  // Notifies the surface of the ideal frame rate that the content is updated
+  // at. This can be used to tune the hardware refresh rate.
+  virtual void SetFrameRate(float frame_rate) {}
 };
 
 }  // namespace gpu
diff --git gpu/command_buffer/client/implementation_base.cc gpu/command_buffer/client/implementation_base.cc
index 4af30994b8ce9..1fa0ff79476ad 100644
--- gpu/command_buffer/client/implementation_base.cc
+++ gpu/command_buffer/client/implementation_base.cc
@@ -414,4 +414,14 @@ void ImplementationBase::DidCallGLFromSkia() {
   NOTREACHED();
 }
 
+void ImplementationBase::SetDisplayTransform(gfx::OverlayTransform transform) {
+  helper_->Flush();
+  gpu_control_->SetDisplayTransform(transform);
+}
+
+void ImplementationBase::SetFrameRate(float frame_rate) {
+  helper_->Flush();
+  gpu_control_->SetFrameRate(frame_rate);
+}
+
 }  // namespace gpu
diff --git gpu/command_buffer/client/implementation_base.h gpu/command_buffer/client/implementation_base.h
index 8a7959109df8c..f83904ac1e192 100644
--- gpu/command_buffer/client/implementation_base.h
+++ gpu/command_buffer/client/implementation_base.h
@@ -90,6 +90,8 @@ class GLES2_IMPL_EXPORT ImplementationBase
   bool HasGrContextSupport() const override;
   void WillCallGLFromSkia() override;
   void DidCallGLFromSkia() override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
+  void SetFrameRate(float frame_rate) override;
 
   // base::trace_event::MemoryDumpProvider implementation.
   bool OnMemoryDump(const base::trace_event::MemoryDumpArgs& args,
diff --git gpu/command_buffer/client/raster_implementation.cc gpu/command_buffer/client/raster_implementation.cc
index b971ed0367323..77e7cd96e2753 100644
--- gpu/command_buffer/client/raster_implementation.cc
+++ gpu/command_buffer/client/raster_implementation.cc
@@ -617,6 +617,47 @@ void RasterImplementation::SetAggressivelyFreeResources(
   }
 }
 
+void RasterImplementation::Swap(
+    uint32_t /* flags */,
+    SwapCompletedCallback /* swap_completed */,
+    PresentationCallback /* presentation_callback */) {
+  NOTREACHED();
+}
+
+void RasterImplementation::SwapWithBounds(
+    const std::vector<gfx::Rect>& /* rects */,
+    uint32_t /* flags */,
+    SwapCompletedCallback /* swap_completed */,
+    PresentationCallback /* presentation_callback */) {
+  NOTREACHED();
+}
+
+void RasterImplementation::PartialSwapBuffers(
+    const gfx::Rect& /* sub_buffer */,
+    uint32_t /* flags */,
+    SwapCompletedCallback /* swap_completed */,
+    PresentationCallback /* presentation_callback */) {
+  NOTREACHED();
+}
+
+void RasterImplementation::CommitOverlayPlanes(
+    uint32_t /* flags */,
+    SwapCompletedCallback /* swap_completed */,
+    PresentationCallback /* presentation_callback */) {
+  NOTREACHED();
+}
+
+void RasterImplementation::ScheduleOverlayPlane(
+    int /* plane_z_order */,
+    gfx::OverlayTransform /* plane_transform */,
+    unsigned /* overlay_texture_id */,
+    const gfx::Rect& /* display_bounds */,
+    const gfx::RectF& /* uv_rect */,
+    bool /* enable_blend */,
+    unsigned /* gpu_fence_id */) {
+  NOTREACHED();
+}
+
 uint64_t RasterImplementation::ShareGroupTracingGUID() const {
   NOTREACHED();
   return 0;
diff --git gpu/command_buffer/client/raster_implementation.h gpu/command_buffer/client/raster_implementation.h
index a94b8a2d6346a..40e9570dda826 100644
--- gpu/command_buffer/client/raster_implementation.h
+++ gpu/command_buffer/client/raster_implementation.h
@@ -215,6 +215,27 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
 
   // ContextSupport implementation.
   void SetAggressivelyFreeResources(bool aggressively_free_resources) override;
+  void Swap(uint32_t flags,
+            SwapCompletedCallback swap_completed,
+            PresentationCallback present_callback) override;
+  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                      uint32_t flags,
+                      SwapCompletedCallback swap_completed,
+                      PresentationCallback present_callback) override;
+  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
+                          uint32_t flags,
+                          SwapCompletedCallback swap_completed,
+                          PresentationCallback present_callback) override;
+  void CommitOverlayPlanes(uint32_t flags,
+                           SwapCompletedCallback swap_completed,
+                           PresentationCallback present_callback) override;
+  void ScheduleOverlayPlane(int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            unsigned overlay_texture_id,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& uv_rect,
+                            bool enable_blend,
+                            unsigned gpu_fence_id) override;
   uint64_t ShareGroupTracingGUID() const override;
   void SetErrorMessageCallback(
       base::RepeatingCallback<void(const char*, int32_t)> callback) override;
diff --git gpu/command_buffer/client/raster_implementation_gles_unittest.cc gpu/command_buffer/client/raster_implementation_gles_unittest.cc
index bfca34e34c3fb..ecb33b888c7d2 100644
--- gpu/command_buffer/client/raster_implementation_gles_unittest.cc
+++ gpu/command_buffer/client/raster_implementation_gles_unittest.cc
@@ -158,6 +158,29 @@ class ContextSupportStub : public ContextSupport {
   void SetAggressivelyFreeResources(bool aggressively_free_resources) override {
   }
 
+  void Swap(uint32_t flags,
+            SwapCompletedCallback swap_completed,
+            PresentationCallback presentation_callback) override {}
+  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                      uint32_t flags,
+                      SwapCompletedCallback swap_completed,
+                      PresentationCallback presentation_callback) override {}
+  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
+                          uint32_t flags,
+                          SwapCompletedCallback swap_completed,
+                          PresentationCallback presentation_callback) override {
+  }
+  void CommitOverlayPlanes(
+      uint32_t flags,
+      SwapCompletedCallback swap_completed,
+      PresentationCallback presentation_callback) override {}
+  void ScheduleOverlayPlane(int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            unsigned overlay_texture_id,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& uv_rect,
+                            bool enable_blend,
+                            unsigned gpu_fence_id) override {}
   uint64_t ShareGroupTracingGUID() const override { return 0; }
   void SetErrorMessageCallback(
       base::RepeatingCallback<void(const char*, int32_t)> callback) override {}
@@ -194,6 +217,8 @@ class ContextSupportStub : public ContextSupport {
   void SetGrContext(GrDirectContext* gr) override {}
   void WillCallGLFromSkia() override {}
   void DidCallGLFromSkia() override {}
+  void SetDisplayTransform(gfx::OverlayTransform transform) override {}
+  void SetFrameRate(float frame_rate) override {}
 
  private:
   std::unique_ptr<char[]> mapped_transfer_cache_entry_;
diff --git gpu/command_buffer/client/webgpu_implementation.cc gpu/command_buffer/client/webgpu_implementation.cc
index ce73008646163..11e6fe22dff60 100644
--- gpu/command_buffer/client/webgpu_implementation.cc
+++ gpu/command_buffer/client/webgpu_implementation.cc
@@ -155,6 +155,41 @@ void WebGPUImplementation::SetAggressivelyFreeResources(
     bool aggressively_free_resources) {
   NOTIMPLEMENTED();
 }
+void WebGPUImplementation::Swap(uint32_t flags,
+                                SwapCompletedCallback complete_callback,
+                                PresentationCallback presentation_callback) {
+  NOTIMPLEMENTED();
+}
+void WebGPUImplementation::SwapWithBounds(
+    const std::vector<gfx::Rect>& rects,
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  NOTIMPLEMENTED();
+}
+void WebGPUImplementation::PartialSwapBuffers(
+    const gfx::Rect& sub_buffer,
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  NOTIMPLEMENTED();
+}
+void WebGPUImplementation::CommitOverlayPlanes(
+    uint32_t flags,
+    SwapCompletedCallback swap_completed,
+    PresentationCallback presentation_callback) {
+  NOTREACHED();
+}
+void WebGPUImplementation::ScheduleOverlayPlane(
+    int plane_z_order,
+    gfx::OverlayTransform plane_transform,
+    unsigned overlay_texture_id,
+    const gfx::Rect& display_bounds,
+    const gfx::RectF& uv_rect,
+    bool enable_blend,
+    unsigned gpu_fence_id) {
+  NOTREACHED();
+}
 uint64_t WebGPUImplementation::ShareGroupTracingGUID() const {
   NOTIMPLEMENTED();
   return 0;
diff --git gpu/command_buffer/client/webgpu_implementation.h gpu/command_buffer/client/webgpu_implementation.h
index dd9612c5950fa..72fbce5dac8cc 100644
--- gpu/command_buffer/client/webgpu_implementation.h
+++ gpu/command_buffer/client/webgpu_implementation.h
@@ -47,6 +47,27 @@ class WEBGPU_EXPORT WebGPUImplementation final : public WebGPUInterface,
 
   // ContextSupport implementation.
   void SetAggressivelyFreeResources(bool aggressively_free_resources) override;
+  void Swap(uint32_t flags,
+            SwapCompletedCallback complete_callback,
+            PresentationCallback presentation_callback) override;
+  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
+                      uint32_t flags,
+                      SwapCompletedCallback swap_completed,
+                      PresentationCallback presentation_callback) override;
+  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
+                          uint32_t flags,
+                          SwapCompletedCallback swap_completed,
+                          PresentationCallback presentation_callback) override;
+  void CommitOverlayPlanes(uint32_t flags,
+                           SwapCompletedCallback swap_completed,
+                           PresentationCallback presentation_callback) override;
+  void ScheduleOverlayPlane(int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            unsigned overlay_texture_id,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& uv_rect,
+                            bool enable_blend,
+                            unsigned gpu_fence_id) override;
   uint64_t ShareGroupTracingGUID() const override;
   void SetErrorMessageCallback(
       base::RepeatingCallback<void(const char*, int32_t)> callback) override;
diff --git gpu/command_buffer/common/gles2_cmd_format_autogen.h gpu/command_buffer/common/gles2_cmd_format_autogen.h
index 65467b7547655..c201823ce219b 100644
--- gpu/command_buffer/common/gles2_cmd_format_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_autogen.h
@@ -13900,6 +13900,80 @@ static_assert(offsetof(GetTranslatedShaderSourceANGLE, shader) == 4,
 static_assert(offsetof(GetTranslatedShaderSourceANGLE, bucket_id) == 8,
               "offset of GetTranslatedShaderSourceANGLE bucket_id should be 8");
 
+struct PostSubBufferCHROMIUM {
+  typedef PostSubBufferCHROMIUM ValueType;
+  static const CommandId kCmdId = kPostSubBufferCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _swap_id,
+            GLint _x,
+            GLint _y,
+            GLint _width,
+            GLint _height,
+            GLbitfield _flags) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_swap_id), &swap_id_0,
+                                    &swap_id_1);
+    x = _x;
+    y = _y;
+    width = _width;
+    height = _height;
+    flags = _flags;
+  }
+
+  void* Set(void* cmd,
+            GLuint64 _swap_id,
+            GLint _x,
+            GLint _y,
+            GLint _width,
+            GLint _height,
+            GLbitfield _flags) {
+    static_cast<ValueType*>(cmd)->Init(_swap_id, _x, _y, _width, _height,
+                                       _flags);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 swap_id() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(swap_id_0, swap_id_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t swap_id_0;
+  uint32_t swap_id_1;
+  int32_t x;
+  int32_t y;
+  int32_t width;
+  int32_t height;
+  uint32_t flags;
+};
+
+static_assert(sizeof(PostSubBufferCHROMIUM) == 32,
+              "size of PostSubBufferCHROMIUM should be 32");
+static_assert(offsetof(PostSubBufferCHROMIUM, header) == 0,
+              "offset of PostSubBufferCHROMIUM header should be 0");
+static_assert(offsetof(PostSubBufferCHROMIUM, swap_id_0) == 4,
+              "offset of PostSubBufferCHROMIUM swap_id_0 should be 4");
+static_assert(offsetof(PostSubBufferCHROMIUM, swap_id_1) == 8,
+              "offset of PostSubBufferCHROMIUM swap_id_1 should be 8");
+static_assert(offsetof(PostSubBufferCHROMIUM, x) == 12,
+              "offset of PostSubBufferCHROMIUM x should be 12");
+static_assert(offsetof(PostSubBufferCHROMIUM, y) == 16,
+              "offset of PostSubBufferCHROMIUM y should be 16");
+static_assert(offsetof(PostSubBufferCHROMIUM, width) == 20,
+              "offset of PostSubBufferCHROMIUM width should be 20");
+static_assert(offsetof(PostSubBufferCHROMIUM, height) == 24,
+              "offset of PostSubBufferCHROMIUM height should be 24");
+static_assert(offsetof(PostSubBufferCHROMIUM, flags) == 28,
+              "offset of PostSubBufferCHROMIUM flags should be 28");
+
 struct CopyTextureCHROMIUM {
   typedef CopyTextureCHROMIUM ValueType;
   static const CommandId kCmdId = kCopyTextureCHROMIUM;
@@ -14757,6 +14831,345 @@ static_assert(sizeof(DiscardBackbufferCHROMIUM) == 4,
 static_assert(offsetof(DiscardBackbufferCHROMIUM, header) == 0,
               "offset of DiscardBackbufferCHROMIUM header should be 0");
 
+struct ScheduleOverlayPlaneCHROMIUM {
+  typedef ScheduleOverlayPlaneCHROMIUM ValueType;
+  static const CommandId kCmdId = kScheduleOverlayPlaneCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLint _plane_z_order,
+            GLenum _plane_transform,
+            GLuint _overlay_texture_id,
+            GLint _bounds_x,
+            GLint _bounds_y,
+            GLint _bounds_width,
+            GLint _bounds_height,
+            GLfloat _uv_x,
+            GLfloat _uv_y,
+            GLfloat _uv_width,
+            GLfloat _uv_height,
+            GLboolean _enable_blend,
+            GLuint _gpu_fence_id) {
+    SetHeader();
+    plane_z_order = _plane_z_order;
+    plane_transform = _plane_transform;
+    overlay_texture_id = _overlay_texture_id;
+    bounds_x = _bounds_x;
+    bounds_y = _bounds_y;
+    bounds_width = _bounds_width;
+    bounds_height = _bounds_height;
+    uv_x = _uv_x;
+    uv_y = _uv_y;
+    uv_width = _uv_width;
+    uv_height = _uv_height;
+    enable_blend = _enable_blend;
+    gpu_fence_id = _gpu_fence_id;
+  }
+
+  void* Set(void* cmd,
+            GLint _plane_z_order,
+            GLenum _plane_transform,
+            GLuint _overlay_texture_id,
+            GLint _bounds_x,
+            GLint _bounds_y,
+            GLint _bounds_width,
+            GLint _bounds_height,
+            GLfloat _uv_x,
+            GLfloat _uv_y,
+            GLfloat _uv_width,
+            GLfloat _uv_height,
+            GLboolean _enable_blend,
+            GLuint _gpu_fence_id) {
+    static_cast<ValueType*>(cmd)->Init(
+        _plane_z_order, _plane_transform, _overlay_texture_id, _bounds_x,
+        _bounds_y, _bounds_width, _bounds_height, _uv_x, _uv_y, _uv_width,
+        _uv_height, _enable_blend, _gpu_fence_id);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  int32_t plane_z_order;
+  uint32_t plane_transform;
+  uint32_t overlay_texture_id;
+  int32_t bounds_x;
+  int32_t bounds_y;
+  int32_t bounds_width;
+  int32_t bounds_height;
+  float uv_x;
+  float uv_y;
+  float uv_width;
+  float uv_height;
+  uint32_t enable_blend;
+  uint32_t gpu_fence_id;
+};
+
+static_assert(sizeof(ScheduleOverlayPlaneCHROMIUM) == 56,
+              "size of ScheduleOverlayPlaneCHROMIUM should be 56");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, header) == 0,
+              "offset of ScheduleOverlayPlaneCHROMIUM header should be 0");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, plane_z_order) == 4,
+    "offset of ScheduleOverlayPlaneCHROMIUM plane_z_order should be 4");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, plane_transform) == 8,
+    "offset of ScheduleOverlayPlaneCHROMIUM plane_transform should be 8");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, overlay_texture_id) == 12,
+    "offset of ScheduleOverlayPlaneCHROMIUM overlay_texture_id should be 12");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, bounds_x) == 16,
+              "offset of ScheduleOverlayPlaneCHROMIUM bounds_x should be 16");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, bounds_y) == 20,
+              "offset of ScheduleOverlayPlaneCHROMIUM bounds_y should be 20");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, bounds_width) == 24,
+    "offset of ScheduleOverlayPlaneCHROMIUM bounds_width should be 24");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, bounds_height) == 28,
+    "offset of ScheduleOverlayPlaneCHROMIUM bounds_height should be 28");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, uv_x) == 32,
+              "offset of ScheduleOverlayPlaneCHROMIUM uv_x should be 32");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, uv_y) == 36,
+              "offset of ScheduleOverlayPlaneCHROMIUM uv_y should be 36");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, uv_width) == 40,
+              "offset of ScheduleOverlayPlaneCHROMIUM uv_width should be 40");
+static_assert(offsetof(ScheduleOverlayPlaneCHROMIUM, uv_height) == 44,
+              "offset of ScheduleOverlayPlaneCHROMIUM uv_height should be 44");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, enable_blend) == 48,
+    "offset of ScheduleOverlayPlaneCHROMIUM enable_blend should be 48");
+static_assert(
+    offsetof(ScheduleOverlayPlaneCHROMIUM, gpu_fence_id) == 52,
+    "offset of ScheduleOverlayPlaneCHROMIUM gpu_fence_id should be 52");
+
+struct ScheduleCALayerSharedStateCHROMIUM {
+  typedef ScheduleCALayerSharedStateCHROMIUM ValueType;
+  static const CommandId kCmdId = kScheduleCALayerSharedStateCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLfloat _opacity,
+            GLboolean _is_clipped,
+            GLint _sorting_context_id,
+            GLuint _shm_id,
+            GLuint _shm_offset) {
+    SetHeader();
+    opacity = _opacity;
+    is_clipped = _is_clipped;
+    sorting_context_id = _sorting_context_id;
+    shm_id = _shm_id;
+    shm_offset = _shm_offset;
+  }
+
+  void* Set(void* cmd,
+            GLfloat _opacity,
+            GLboolean _is_clipped,
+            GLint _sorting_context_id,
+            GLuint _shm_id,
+            GLuint _shm_offset) {
+    static_cast<ValueType*>(cmd)->Init(
+        _opacity, _is_clipped, _sorting_context_id, _shm_id, _shm_offset);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  float opacity;
+  uint32_t is_clipped;
+  int32_t sorting_context_id;
+  uint32_t shm_id;
+  uint32_t shm_offset;
+};
+
+static_assert(sizeof(ScheduleCALayerSharedStateCHROMIUM) == 24,
+              "size of ScheduleCALayerSharedStateCHROMIUM should be 24");
+static_assert(
+    offsetof(ScheduleCALayerSharedStateCHROMIUM, header) == 0,
+    "offset of ScheduleCALayerSharedStateCHROMIUM header should be 0");
+static_assert(
+    offsetof(ScheduleCALayerSharedStateCHROMIUM, opacity) == 4,
+    "offset of ScheduleCALayerSharedStateCHROMIUM opacity should be 4");
+static_assert(
+    offsetof(ScheduleCALayerSharedStateCHROMIUM, is_clipped) == 8,
+    "offset of ScheduleCALayerSharedStateCHROMIUM is_clipped should be 8");
+static_assert(offsetof(ScheduleCALayerSharedStateCHROMIUM,
+                       sorting_context_id) == 12,
+              "offset of ScheduleCALayerSharedStateCHROMIUM sorting_context_id "
+              "should be 12");
+static_assert(
+    offsetof(ScheduleCALayerSharedStateCHROMIUM, shm_id) == 16,
+    "offset of ScheduleCALayerSharedStateCHROMIUM shm_id should be 16");
+static_assert(
+    offsetof(ScheduleCALayerSharedStateCHROMIUM, shm_offset) == 20,
+    "offset of ScheduleCALayerSharedStateCHROMIUM shm_offset should be 20");
+
+struct ScheduleCALayerCHROMIUM {
+  typedef ScheduleCALayerCHROMIUM ValueType;
+  static const CommandId kCmdId = kScheduleCALayerCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint _contents_texture_id,
+            GLuint _background_color,
+            GLuint _edge_aa_mask,
+            GLuint _filter,
+            GLuint _shm_id,
+            GLuint _shm_offset) {
+    SetHeader();
+    contents_texture_id = _contents_texture_id;
+    background_color = _background_color;
+    edge_aa_mask = _edge_aa_mask;
+    filter = _filter;
+    shm_id = _shm_id;
+    shm_offset = _shm_offset;
+  }
+
+  void* Set(void* cmd,
+            GLuint _contents_texture_id,
+            GLuint _background_color,
+            GLuint _edge_aa_mask,
+            GLuint _filter,
+            GLuint _shm_id,
+            GLuint _shm_offset) {
+    static_cast<ValueType*>(cmd)->Init(_contents_texture_id, _background_color,
+                                       _edge_aa_mask, _filter, _shm_id,
+                                       _shm_offset);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  uint32_t contents_texture_id;
+  uint32_t background_color;
+  uint32_t edge_aa_mask;
+  uint32_t filter;
+  uint32_t shm_id;
+  uint32_t shm_offset;
+};
+
+static_assert(sizeof(ScheduleCALayerCHROMIUM) == 28,
+              "size of ScheduleCALayerCHROMIUM should be 28");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, header) == 0,
+              "offset of ScheduleCALayerCHROMIUM header should be 0");
+static_assert(
+    offsetof(ScheduleCALayerCHROMIUM, contents_texture_id) == 4,
+    "offset of ScheduleCALayerCHROMIUM contents_texture_id should be 4");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, background_color) == 8,
+              "offset of ScheduleCALayerCHROMIUM background_color should be 8");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, edge_aa_mask) == 12,
+              "offset of ScheduleCALayerCHROMIUM edge_aa_mask should be 12");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, filter) == 16,
+              "offset of ScheduleCALayerCHROMIUM filter should be 16");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, shm_id) == 20,
+              "offset of ScheduleCALayerCHROMIUM shm_id should be 20");
+static_assert(offsetof(ScheduleCALayerCHROMIUM, shm_offset) == 24,
+              "offset of ScheduleCALayerCHROMIUM shm_offset should be 24");
+
+struct ScheduleCALayerInUseQueryCHROMIUMImmediate {
+  typedef ScheduleCALayerInUseQueryCHROMIUMImmediate ValueType;
+  static const CommandId kCmdId = kScheduleCALayerInUseQueryCHROMIUMImmediate;
+  static const cmd::ArgFlags kArgFlags = cmd::kAtLeastN;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeDataSize(GLsizei _n) {
+    return static_cast<uint32_t>(sizeof(GLuint) * 1 * _n);  // NOLINT
+  }
+
+  static uint32_t ComputeSize(GLsizei _n) {
+    return static_cast<uint32_t>(sizeof(ValueType) +
+                                 ComputeDataSize(_n));  // NOLINT
+  }
+
+  void SetHeader(GLsizei _n) {
+    header.SetCmdByTotalSize<ValueType>(ComputeSize(_n));
+  }
+
+  void Init(GLsizei _count, const GLuint* _textures) {
+    SetHeader(_count);
+    count = _count;
+    memcpy(ImmediateDataAddress(this), _textures, ComputeDataSize(_count));
+  }
+
+  void* Set(void* cmd, GLsizei _count, const GLuint* _textures) {
+    static_cast<ValueType*>(cmd)->Init(_count, _textures);
+    const uint32_t size = ComputeSize(_count);
+    return NextImmediateCmdAddressTotalSize<ValueType>(cmd, size);
+  }
+
+  gpu::CommandHeader header;
+  int32_t count;
+};
+
+static_assert(sizeof(ScheduleCALayerInUseQueryCHROMIUMImmediate) == 8,
+              "size of ScheduleCALayerInUseQueryCHROMIUMImmediate should be 8");
+static_assert(
+    offsetof(ScheduleCALayerInUseQueryCHROMIUMImmediate, header) == 0,
+    "offset of ScheduleCALayerInUseQueryCHROMIUMImmediate header should be 0");
+static_assert(
+    offsetof(ScheduleCALayerInUseQueryCHROMIUMImmediate, count) == 4,
+    "offset of ScheduleCALayerInUseQueryCHROMIUMImmediate count should be 4");
+
+struct CommitOverlayPlanesCHROMIUM {
+  typedef CommitOverlayPlanesCHROMIUM ValueType;
+  static const CommandId kCmdId = kCommitOverlayPlanesCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _swap_id, GLbitfield _flags) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_swap_id), &swap_id_0,
+                                    &swap_id_1);
+    flags = _flags;
+  }
+
+  void* Set(void* cmd, GLuint64 _swap_id, GLbitfield _flags) {
+    static_cast<ValueType*>(cmd)->Init(_swap_id, _flags);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 swap_id() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(swap_id_0, swap_id_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t swap_id_0;
+  uint32_t swap_id_1;
+  uint32_t flags;
+};
+
+static_assert(sizeof(CommitOverlayPlanesCHROMIUM) == 16,
+              "size of CommitOverlayPlanesCHROMIUM should be 16");
+static_assert(offsetof(CommitOverlayPlanesCHROMIUM, header) == 0,
+              "offset of CommitOverlayPlanesCHROMIUM header should be 0");
+static_assert(offsetof(CommitOverlayPlanesCHROMIUM, swap_id_0) == 4,
+              "offset of CommitOverlayPlanesCHROMIUM swap_id_0 should be 4");
+static_assert(offsetof(CommitOverlayPlanesCHROMIUM, swap_id_1) == 8,
+              "offset of CommitOverlayPlanesCHROMIUM swap_id_1 should be 8");
+static_assert(offsetof(CommitOverlayPlanesCHROMIUM, flags) == 12,
+              "offset of CommitOverlayPlanesCHROMIUM flags should be 12");
+
 struct FlushDriverCachesCHROMIUM {
   typedef FlushDriverCachesCHROMIUM ValueType;
   static const CommandId kCmdId = kFlushDriverCachesCHROMIUM;
@@ -14784,6 +15197,178 @@ static_assert(sizeof(FlushDriverCachesCHROMIUM) == 4,
 static_assert(offsetof(FlushDriverCachesCHROMIUM, header) == 0,
               "offset of FlushDriverCachesCHROMIUM header should be 0");
 
+struct ScheduleDCLayerCHROMIUM {
+  typedef ScheduleDCLayerCHROMIUM ValueType;
+  static const CommandId kCmdId = kScheduleDCLayerCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint _texture_0,
+            GLuint _texture_1,
+            GLint _z_order,
+            GLint _content_x,
+            GLint _content_y,
+            GLint _content_width,
+            GLint _content_height,
+            GLint _quad_x,
+            GLint _quad_y,
+            GLint _quad_width,
+            GLint _quad_height,
+            GLfloat _transform_c1r1,
+            GLfloat _transform_c2r1,
+            GLfloat _transform_c1r2,
+            GLfloat _transform_c2r2,
+            GLfloat _transform_tx,
+            GLfloat _transform_ty,
+            GLboolean _is_clipped,
+            GLint _clip_x,
+            GLint _clip_y,
+            GLint _clip_width,
+            GLint _clip_height,
+            GLuint _protected_video_type) {
+    SetHeader();
+    texture_0 = _texture_0;
+    texture_1 = _texture_1;
+    z_order = _z_order;
+    content_x = _content_x;
+    content_y = _content_y;
+    content_width = _content_width;
+    content_height = _content_height;
+    quad_x = _quad_x;
+    quad_y = _quad_y;
+    quad_width = _quad_width;
+    quad_height = _quad_height;
+    transform_c1r1 = _transform_c1r1;
+    transform_c2r1 = _transform_c2r1;
+    transform_c1r2 = _transform_c1r2;
+    transform_c2r2 = _transform_c2r2;
+    transform_tx = _transform_tx;
+    transform_ty = _transform_ty;
+    is_clipped = _is_clipped;
+    clip_x = _clip_x;
+    clip_y = _clip_y;
+    clip_width = _clip_width;
+    clip_height = _clip_height;
+    protected_video_type = _protected_video_type;
+  }
+
+  void* Set(void* cmd,
+            GLuint _texture_0,
+            GLuint _texture_1,
+            GLint _z_order,
+            GLint _content_x,
+            GLint _content_y,
+            GLint _content_width,
+            GLint _content_height,
+            GLint _quad_x,
+            GLint _quad_y,
+            GLint _quad_width,
+            GLint _quad_height,
+            GLfloat _transform_c1r1,
+            GLfloat _transform_c2r1,
+            GLfloat _transform_c1r2,
+            GLfloat _transform_c2r2,
+            GLfloat _transform_tx,
+            GLfloat _transform_ty,
+            GLboolean _is_clipped,
+            GLint _clip_x,
+            GLint _clip_y,
+            GLint _clip_width,
+            GLint _clip_height,
+            GLuint _protected_video_type) {
+    static_cast<ValueType*>(cmd)->Init(
+        _texture_0, _texture_1, _z_order, _content_x, _content_y,
+        _content_width, _content_height, _quad_x, _quad_y, _quad_width,
+        _quad_height, _transform_c1r1, _transform_c2r1, _transform_c1r2,
+        _transform_c2r2, _transform_tx, _transform_ty, _is_clipped, _clip_x,
+        _clip_y, _clip_width, _clip_height, _protected_video_type);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  uint32_t texture_0;
+  uint32_t texture_1;
+  int32_t z_order;
+  int32_t content_x;
+  int32_t content_y;
+  int32_t content_width;
+  int32_t content_height;
+  int32_t quad_x;
+  int32_t quad_y;
+  int32_t quad_width;
+  int32_t quad_height;
+  float transform_c1r1;
+  float transform_c2r1;
+  float transform_c1r2;
+  float transform_c2r2;
+  float transform_tx;
+  float transform_ty;
+  uint32_t is_clipped;
+  int32_t clip_x;
+  int32_t clip_y;
+  int32_t clip_width;
+  int32_t clip_height;
+  uint32_t protected_video_type;
+};
+
+static_assert(sizeof(ScheduleDCLayerCHROMIUM) == 96,
+              "size of ScheduleDCLayerCHROMIUM should be 96");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, header) == 0,
+              "offset of ScheduleDCLayerCHROMIUM header should be 0");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, texture_0) == 4,
+              "offset of ScheduleDCLayerCHROMIUM texture_0 should be 4");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, texture_1) == 8,
+              "offset of ScheduleDCLayerCHROMIUM texture_1 should be 8");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, z_order) == 12,
+              "offset of ScheduleDCLayerCHROMIUM z_order should be 12");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, content_x) == 16,
+              "offset of ScheduleDCLayerCHROMIUM content_x should be 16");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, content_y) == 20,
+              "offset of ScheduleDCLayerCHROMIUM content_y should be 20");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, content_width) == 24,
+              "offset of ScheduleDCLayerCHROMIUM content_width should be 24");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, content_height) == 28,
+              "offset of ScheduleDCLayerCHROMIUM content_height should be 28");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, quad_x) == 32,
+              "offset of ScheduleDCLayerCHROMIUM quad_x should be 32");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, quad_y) == 36,
+              "offset of ScheduleDCLayerCHROMIUM quad_y should be 36");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, quad_width) == 40,
+              "offset of ScheduleDCLayerCHROMIUM quad_width should be 40");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, quad_height) == 44,
+              "offset of ScheduleDCLayerCHROMIUM quad_height should be 44");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_c1r1) == 48,
+              "offset of ScheduleDCLayerCHROMIUM transform_c1r1 should be 48");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_c2r1) == 52,
+              "offset of ScheduleDCLayerCHROMIUM transform_c2r1 should be 52");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_c1r2) == 56,
+              "offset of ScheduleDCLayerCHROMIUM transform_c1r2 should be 56");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_c2r2) == 60,
+              "offset of ScheduleDCLayerCHROMIUM transform_c2r2 should be 60");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_tx) == 64,
+              "offset of ScheduleDCLayerCHROMIUM transform_tx should be 64");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, transform_ty) == 68,
+              "offset of ScheduleDCLayerCHROMIUM transform_ty should be 68");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, is_clipped) == 72,
+              "offset of ScheduleDCLayerCHROMIUM is_clipped should be 72");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, clip_x) == 76,
+              "offset of ScheduleDCLayerCHROMIUM clip_x should be 76");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, clip_y) == 80,
+              "offset of ScheduleDCLayerCHROMIUM clip_y should be 80");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, clip_width) == 84,
+              "offset of ScheduleDCLayerCHROMIUM clip_width should be 84");
+static_assert(offsetof(ScheduleDCLayerCHROMIUM, clip_height) == 88,
+              "offset of ScheduleDCLayerCHROMIUM clip_height should be 88");
+static_assert(
+    offsetof(ScheduleDCLayerCHROMIUM, protected_video_type) == 92,
+    "offset of ScheduleDCLayerCHROMIUM protected_video_type should be 92");
+
 struct SetActiveURLCHROMIUM {
   typedef SetActiveURLCHROMIUM ValueType;
   static const CommandId kCmdId = kSetActiveURLCHROMIUM;
@@ -15070,6 +15655,155 @@ static_assert(offsetof(GetFragDataIndexEXT, index_shm_id) == 12,
 static_assert(offsetof(GetFragDataIndexEXT, index_shm_offset) == 16,
               "offset of GetFragDataIndexEXT index_shm_offset should be 16");
 
+struct SwapBuffersWithBoundsCHROMIUMImmediate {
+  typedef SwapBuffersWithBoundsCHROMIUMImmediate ValueType;
+  static const CommandId kCmdId = kSwapBuffersWithBoundsCHROMIUMImmediate;
+  static const cmd::ArgFlags kArgFlags = cmd::kAtLeastN;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeDataSize(GLsizei _n) {
+    return static_cast<uint32_t>(sizeof(GLint) * 4 * _n);  // NOLINT
+  }
+
+  static uint32_t ComputeSize(GLsizei _n) {
+    return static_cast<uint32_t>(sizeof(ValueType) +
+                                 ComputeDataSize(_n));  // NOLINT
+  }
+
+  void SetHeader(GLsizei _n) {
+    header.SetCmdByTotalSize<ValueType>(ComputeSize(_n));
+  }
+
+  void Init(GLuint64 _swap_id,
+            GLsizei _count,
+            const GLint* _rects,
+            GLbitfield _flags) {
+    SetHeader(_count);
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_swap_id), &swap_id_0,
+                                    &swap_id_1);
+    count = _count;
+    flags = _flags;
+    memcpy(ImmediateDataAddress(this), _rects, ComputeDataSize(_count));
+  }
+
+  void* Set(void* cmd,
+            GLuint64 _swap_id,
+            GLsizei _count,
+            const GLint* _rects,
+            GLbitfield _flags) {
+    static_cast<ValueType*>(cmd)->Init(_swap_id, _count, _rects, _flags);
+    const uint32_t size = ComputeSize(_count);
+    return NextImmediateCmdAddressTotalSize<ValueType>(cmd, size);
+  }
+
+  GLuint64 swap_id() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(swap_id_0, swap_id_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t swap_id_0;
+  uint32_t swap_id_1;
+  int32_t count;
+  uint32_t flags;
+};
+
+static_assert(sizeof(SwapBuffersWithBoundsCHROMIUMImmediate) == 20,
+              "size of SwapBuffersWithBoundsCHROMIUMImmediate should be 20");
+static_assert(
+    offsetof(SwapBuffersWithBoundsCHROMIUMImmediate, header) == 0,
+    "offset of SwapBuffersWithBoundsCHROMIUMImmediate header should be 0");
+static_assert(
+    offsetof(SwapBuffersWithBoundsCHROMIUMImmediate, swap_id_0) == 4,
+    "offset of SwapBuffersWithBoundsCHROMIUMImmediate swap_id_0 should be 4");
+static_assert(
+    offsetof(SwapBuffersWithBoundsCHROMIUMImmediate, swap_id_1) == 8,
+    "offset of SwapBuffersWithBoundsCHROMIUMImmediate swap_id_1 should be 8");
+static_assert(
+    offsetof(SwapBuffersWithBoundsCHROMIUMImmediate, count) == 12,
+    "offset of SwapBuffersWithBoundsCHROMIUMImmediate count should be 12");
+static_assert(
+    offsetof(SwapBuffersWithBoundsCHROMIUMImmediate, flags) == 16,
+    "offset of SwapBuffersWithBoundsCHROMIUMImmediate flags should be 16");
+
+struct SetDrawRectangleCHROMIUM {
+  typedef SetDrawRectangleCHROMIUM ValueType;
+  static const CommandId kCmdId = kSetDrawRectangleCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLint _x, GLint _y, GLint _width, GLint _height) {
+    SetHeader();
+    x = _x;
+    y = _y;
+    width = _width;
+    height = _height;
+  }
+
+  void* Set(void* cmd, GLint _x, GLint _y, GLint _width, GLint _height) {
+    static_cast<ValueType*>(cmd)->Init(_x, _y, _width, _height);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  int32_t x;
+  int32_t y;
+  int32_t width;
+  int32_t height;
+};
+
+static_assert(sizeof(SetDrawRectangleCHROMIUM) == 20,
+              "size of SetDrawRectangleCHROMIUM should be 20");
+static_assert(offsetof(SetDrawRectangleCHROMIUM, header) == 0,
+              "offset of SetDrawRectangleCHROMIUM header should be 0");
+static_assert(offsetof(SetDrawRectangleCHROMIUM, x) == 4,
+              "offset of SetDrawRectangleCHROMIUM x should be 4");
+static_assert(offsetof(SetDrawRectangleCHROMIUM, y) == 8,
+              "offset of SetDrawRectangleCHROMIUM y should be 8");
+static_assert(offsetof(SetDrawRectangleCHROMIUM, width) == 12,
+              "offset of SetDrawRectangleCHROMIUM width should be 12");
+static_assert(offsetof(SetDrawRectangleCHROMIUM, height) == 16,
+              "offset of SetDrawRectangleCHROMIUM height should be 16");
+
+struct SetEnableDCLayersCHROMIUM {
+  typedef SetEnableDCLayersCHROMIUM ValueType;
+  static const CommandId kCmdId = kSetEnableDCLayersCHROMIUM;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLboolean _enabled) {
+    SetHeader();
+    enabled = _enabled;
+  }
+
+  void* Set(void* cmd, GLboolean _enabled) {
+    static_cast<ValueType*>(cmd)->Init(_enabled);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  uint32_t enabled;
+};
+
+static_assert(sizeof(SetEnableDCLayersCHROMIUM) == 8,
+              "size of SetEnableDCLayersCHROMIUM should be 8");
+static_assert(offsetof(SetEnableDCLayersCHROMIUM, header) == 0,
+              "offset of SetEnableDCLayersCHROMIUM header should be 0");
+static_assert(offsetof(SetEnableDCLayersCHROMIUM, enabled) == 4,
+              "offset of SetEnableDCLayersCHROMIUM enabled should be 4");
+
 struct InitializeDiscardableTextureCHROMIUM {
   typedef InitializeDiscardableTextureCHROMIUM ValueType;
   static const CommandId kCmdId = kInitializeDiscardableTextureCHROMIUM;
diff --git gpu/command_buffer/common/gles2_cmd_format_test_autogen.h gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
index d2dd4e4faaac1..0629a0eefc0ce 100644
--- gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
@@ -4575,6 +4575,25 @@ TEST_F(GLES2FormatTest, GetTranslatedShaderSourceANGLE) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
+TEST_F(GLES2FormatTest, PostSubBufferCHROMIUM) {
+  cmds::PostSubBufferCHROMIUM& cmd =
+      *GetBufferAs<cmds::PostSubBufferCHROMIUM>();
+  void* next_cmd =
+      cmd.Set(&cmd, static_cast<GLuint64>(11), static_cast<GLint>(12),
+              static_cast<GLint>(13), static_cast<GLint>(14),
+              static_cast<GLint>(15), static_cast<GLbitfield>(16));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::PostSubBufferCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.swap_id());
+  EXPECT_EQ(static_cast<GLint>(12), cmd.x);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.y);
+  EXPECT_EQ(static_cast<GLint>(14), cmd.width);
+  EXPECT_EQ(static_cast<GLint>(15), cmd.height);
+  EXPECT_EQ(static_cast<GLbitfield>(16), cmd.flags);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 TEST_F(GLES2FormatTest, CopyTextureCHROMIUM) {
   cmds::CopyTextureCHROMIUM& cmd = *GetBufferAs<cmds::CopyTextureCHROMIUM>();
   void* next_cmd =
@@ -4879,6 +4898,105 @@ TEST_F(GLES2FormatTest, DiscardBackbufferCHROMIUM) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
+TEST_F(GLES2FormatTest, ScheduleOverlayPlaneCHROMIUM) {
+  cmds::ScheduleOverlayPlaneCHROMIUM& cmd =
+      *GetBufferAs<cmds::ScheduleOverlayPlaneCHROMIUM>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLint>(11),
+                           static_cast<GLenum>(12), static_cast<GLuint>(13),
+                           static_cast<GLint>(14), static_cast<GLint>(15),
+                           static_cast<GLint>(16), static_cast<GLint>(17),
+                           static_cast<GLfloat>(18), static_cast<GLfloat>(19),
+                           static_cast<GLfloat>(20), static_cast<GLfloat>(21),
+                           static_cast<GLboolean>(22), static_cast<GLuint>(23));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::ScheduleOverlayPlaneCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLint>(11), cmd.plane_z_order);
+  EXPECT_EQ(static_cast<GLenum>(12), cmd.plane_transform);
+  EXPECT_EQ(static_cast<GLuint>(13), cmd.overlay_texture_id);
+  EXPECT_EQ(static_cast<GLint>(14), cmd.bounds_x);
+  EXPECT_EQ(static_cast<GLint>(15), cmd.bounds_y);
+  EXPECT_EQ(static_cast<GLint>(16), cmd.bounds_width);
+  EXPECT_EQ(static_cast<GLint>(17), cmd.bounds_height);
+  EXPECT_EQ(static_cast<GLfloat>(18), cmd.uv_x);
+  EXPECT_EQ(static_cast<GLfloat>(19), cmd.uv_y);
+  EXPECT_EQ(static_cast<GLfloat>(20), cmd.uv_width);
+  EXPECT_EQ(static_cast<GLfloat>(21), cmd.uv_height);
+  EXPECT_EQ(static_cast<GLboolean>(22), cmd.enable_blend);
+  EXPECT_EQ(static_cast<GLuint>(23), cmd.gpu_fence_id);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, ScheduleCALayerSharedStateCHROMIUM) {
+  cmds::ScheduleCALayerSharedStateCHROMIUM& cmd =
+      *GetBufferAs<cmds::ScheduleCALayerSharedStateCHROMIUM>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLfloat>(11),
+                           static_cast<GLboolean>(12), static_cast<GLint>(13),
+                           static_cast<GLuint>(14), static_cast<GLuint>(15));
+  EXPECT_EQ(
+      static_cast<uint32_t>(cmds::ScheduleCALayerSharedStateCHROMIUM::kCmdId),
+      cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLfloat>(11), cmd.opacity);
+  EXPECT_EQ(static_cast<GLboolean>(12), cmd.is_clipped);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.sorting_context_id);
+  EXPECT_EQ(static_cast<GLuint>(14), cmd.shm_id);
+  EXPECT_EQ(static_cast<GLuint>(15), cmd.shm_offset);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, ScheduleCALayerCHROMIUM) {
+  cmds::ScheduleCALayerCHROMIUM& cmd =
+      *GetBufferAs<cmds::ScheduleCALayerCHROMIUM>();
+  void* next_cmd =
+      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLuint>(12),
+              static_cast<GLuint>(13), static_cast<GLuint>(14),
+              static_cast<GLuint>(15), static_cast<GLuint>(16));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::ScheduleCALayerCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint>(11), cmd.contents_texture_id);
+  EXPECT_EQ(static_cast<GLuint>(12), cmd.background_color);
+  EXPECT_EQ(static_cast<GLuint>(13), cmd.edge_aa_mask);
+  EXPECT_EQ(static_cast<GLuint>(14), cmd.filter);
+  EXPECT_EQ(static_cast<GLuint>(15), cmd.shm_id);
+  EXPECT_EQ(static_cast<GLuint>(16), cmd.shm_offset);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, ScheduleCALayerInUseQueryCHROMIUMImmediate) {
+  const int kSomeBaseValueToTestWith = 51;
+  static GLuint data[] = {
+      static_cast<GLuint>(kSomeBaseValueToTestWith + 0),
+  };
+  cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate& cmd =
+      *GetBufferAs<cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate>();
+  const GLsizei kNumElements = 1;
+  const size_t kExpectedCmdSize =
+      sizeof(cmd) + kNumElements * sizeof(GLuint) * 1;
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLsizei>(1), data);
+  EXPECT_EQ(static_cast<uint32_t>(
+                cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(kExpectedCmdSize, cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLsizei>(1), cmd.count);
+  CheckBytesWrittenMatchesExpectedSize(
+      next_cmd, sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)));
+}
+
+TEST_F(GLES2FormatTest, CommitOverlayPlanesCHROMIUM) {
+  cmds::CommitOverlayPlanesCHROMIUM& cmd =
+      *GetBufferAs<cmds::CommitOverlayPlanesCHROMIUM>();
+  void* next_cmd =
+      cmd.Set(&cmd, static_cast<GLuint64>(11), static_cast<GLbitfield>(12));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::CommitOverlayPlanesCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.swap_id());
+  EXPECT_EQ(static_cast<GLbitfield>(12), cmd.flags);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 TEST_F(GLES2FormatTest, FlushDriverCachesCHROMIUM) {
   cmds::FlushDriverCachesCHROMIUM& cmd =
       *GetBufferAs<cmds::FlushDriverCachesCHROMIUM>();
@@ -4889,6 +5007,49 @@ TEST_F(GLES2FormatTest, FlushDriverCachesCHROMIUM) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
+TEST_F(GLES2FormatTest, ScheduleDCLayerCHROMIUM) {
+  cmds::ScheduleDCLayerCHROMIUM& cmd =
+      *GetBufferAs<cmds::ScheduleDCLayerCHROMIUM>();
+  void* next_cmd = cmd.Set(
+      &cmd, static_cast<GLuint>(11), static_cast<GLuint>(12),
+      static_cast<GLint>(13), static_cast<GLint>(14), static_cast<GLint>(15),
+      static_cast<GLint>(16), static_cast<GLint>(17), static_cast<GLint>(18),
+      static_cast<GLint>(19), static_cast<GLint>(20), static_cast<GLint>(21),
+      static_cast<GLfloat>(22), static_cast<GLfloat>(23),
+      static_cast<GLfloat>(24), static_cast<GLfloat>(25),
+      static_cast<GLfloat>(26), static_cast<GLfloat>(27),
+      static_cast<GLboolean>(28), static_cast<GLint>(29),
+      static_cast<GLint>(30), static_cast<GLint>(31), static_cast<GLint>(32),
+      static_cast<GLuint>(33));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::ScheduleDCLayerCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint>(11), cmd.texture_0);
+  EXPECT_EQ(static_cast<GLuint>(12), cmd.texture_1);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.z_order);
+  EXPECT_EQ(static_cast<GLint>(14), cmd.content_x);
+  EXPECT_EQ(static_cast<GLint>(15), cmd.content_y);
+  EXPECT_EQ(static_cast<GLint>(16), cmd.content_width);
+  EXPECT_EQ(static_cast<GLint>(17), cmd.content_height);
+  EXPECT_EQ(static_cast<GLint>(18), cmd.quad_x);
+  EXPECT_EQ(static_cast<GLint>(19), cmd.quad_y);
+  EXPECT_EQ(static_cast<GLint>(20), cmd.quad_width);
+  EXPECT_EQ(static_cast<GLint>(21), cmd.quad_height);
+  EXPECT_EQ(static_cast<GLfloat>(22), cmd.transform_c1r1);
+  EXPECT_EQ(static_cast<GLfloat>(23), cmd.transform_c2r1);
+  EXPECT_EQ(static_cast<GLfloat>(24), cmd.transform_c1r2);
+  EXPECT_EQ(static_cast<GLfloat>(25), cmd.transform_c2r2);
+  EXPECT_EQ(static_cast<GLfloat>(26), cmd.transform_tx);
+  EXPECT_EQ(static_cast<GLfloat>(27), cmd.transform_ty);
+  EXPECT_EQ(static_cast<GLboolean>(28), cmd.is_clipped);
+  EXPECT_EQ(static_cast<GLint>(29), cmd.clip_x);
+  EXPECT_EQ(static_cast<GLint>(30), cmd.clip_y);
+  EXPECT_EQ(static_cast<GLint>(31), cmd.clip_width);
+  EXPECT_EQ(static_cast<GLint>(32), cmd.clip_height);
+  EXPECT_EQ(static_cast<GLuint>(33), cmd.protected_video_type);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 TEST_F(GLES2FormatTest, SetActiveURLCHROMIUM) {
   cmds::SetActiveURLCHROMIUM& cmd = *GetBufferAs<cmds::SetActiveURLCHROMIUM>();
   void* next_cmd = cmd.Set(&cmd, static_cast<GLuint>(11));
@@ -4976,6 +5137,63 @@ TEST_F(GLES2FormatTest, GetFragDataIndexEXT) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
+TEST_F(GLES2FormatTest, SwapBuffersWithBoundsCHROMIUMImmediate) {
+  const int kSomeBaseValueToTestWith = 51;
+  static GLint data[] = {
+      static_cast<GLint>(kSomeBaseValueToTestWith + 0),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 1),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 2),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 3),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 4),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 5),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 6),
+      static_cast<GLint>(kSomeBaseValueToTestWith + 7),
+  };
+  cmds::SwapBuffersWithBoundsCHROMIUMImmediate& cmd =
+      *GetBufferAs<cmds::SwapBuffersWithBoundsCHROMIUMImmediate>();
+  const GLsizei kNumElements = 2;
+  const size_t kExpectedCmdSize =
+      sizeof(cmd) + kNumElements * sizeof(GLint) * 4;
+  void* next_cmd =
+      cmd.Set(&cmd, static_cast<GLuint64>(1), static_cast<GLsizei>(2), data,
+              static_cast<GLbitfield>(4));
+  EXPECT_EQ(static_cast<uint32_t>(
+                cmds::SwapBuffersWithBoundsCHROMIUMImmediate::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(kExpectedCmdSize, cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(1), cmd.swap_id());
+  EXPECT_EQ(static_cast<GLsizei>(2), cmd.count);
+  EXPECT_EQ(static_cast<GLbitfield>(4), cmd.flags);
+  CheckBytesWrittenMatchesExpectedSize(
+      next_cmd, sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)));
+}
+
+TEST_F(GLES2FormatTest, SetDrawRectangleCHROMIUM) {
+  cmds::SetDrawRectangleCHROMIUM& cmd =
+      *GetBufferAs<cmds::SetDrawRectangleCHROMIUM>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLint>(11), static_cast<GLint>(12),
+                           static_cast<GLint>(13), static_cast<GLint>(14));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::SetDrawRectangleCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLint>(11), cmd.x);
+  EXPECT_EQ(static_cast<GLint>(12), cmd.y);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.width);
+  EXPECT_EQ(static_cast<GLint>(14), cmd.height);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, SetEnableDCLayersCHROMIUM) {
+  cmds::SetEnableDCLayersCHROMIUM& cmd =
+      *GetBufferAs<cmds::SetEnableDCLayersCHROMIUM>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLboolean>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::SetEnableDCLayersCHROMIUM::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLboolean>(11), cmd.enabled);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 TEST_F(GLES2FormatTest, InitializeDiscardableTextureCHROMIUM) {
   cmds::InitializeDiscardableTextureCHROMIUM& cmd =
       *GetBufferAs<cmds::InitializeDiscardableTextureCHROMIUM>();
diff --git gpu/command_buffer/common/gles2_cmd_ids_autogen.h gpu/command_buffer/common/gles2_cmd_ids_autogen.h
index 8070bd5903c25..d083cdbfcb74b 100644
--- gpu/command_buffer/common/gles2_cmd_ids_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_ids_autogen.h
@@ -291,55 +291,65 @@
   OP(GetUniformsES3CHROMIUM)                                   /* 532 */ \
   OP(DescheduleUntilFinishedCHROMIUM)                          /* 533 */ \
   OP(GetTranslatedShaderSourceANGLE)                           /* 534 */ \
-  OP(CopyTextureCHROMIUM)                                      /* 535 */ \
-  OP(CopySubTextureCHROMIUM)                                   /* 536 */ \
-  OP(DrawArraysInstancedANGLE)                                 /* 537 */ \
-  OP(DrawArraysInstancedBaseInstanceANGLE)                     /* 538 */ \
-  OP(DrawElementsInstancedANGLE)                               /* 539 */ \
-  OP(DrawElementsInstancedBaseVertexBaseInstanceANGLE)         /* 540 */ \
-  OP(VertexAttribDivisorANGLE)                                 /* 541 */ \
-  OP(ProduceTextureDirectCHROMIUMImmediate)                    /* 542 */ \
-  OP(CreateAndConsumeTextureINTERNALImmediate)                 /* 543 */ \
-  OP(BindUniformLocationCHROMIUMBucket)                        /* 544 */ \
-  OP(TraceBeginCHROMIUM)                                       /* 545 */ \
-  OP(TraceEndCHROMIUM)                                         /* 546 */ \
-  OP(DiscardFramebufferEXTImmediate)                           /* 547 */ \
-  OP(LoseContextCHROMIUM)                                      /* 548 */ \
-  OP(DrawBuffersEXTImmediate)                                  /* 549 */ \
-  OP(DiscardBackbufferCHROMIUM)                                /* 550 */ \
-  OP(FlushDriverCachesCHROMIUM)                                /* 551 */ \
-  OP(SetActiveURLCHROMIUM)                                     /* 552 */ \
-  OP(ContextVisibilityHintCHROMIUM)                            /* 553 */ \
-  OP(CoverageModulationCHROMIUM)                               /* 554 */ \
-  OP(BlendBarrierKHR)                                          /* 555 */ \
-  OP(BindFragDataLocationIndexedEXTBucket)                     /* 556 */ \
-  OP(BindFragDataLocationEXTBucket)                            /* 557 */ \
-  OP(GetFragDataIndexEXT)                                      /* 558 */ \
-  OP(InitializeDiscardableTextureCHROMIUM)                     /* 559 */ \
-  OP(UnlockDiscardableTextureCHROMIUM)                         /* 560 */ \
-  OP(LockDiscardableTextureCHROMIUM)                           /* 561 */ \
-  OP(TexStorage2DImageCHROMIUM)                                /* 562 */ \
-  OP(SetColorSpaceMetadataCHROMIUM)                            /* 563 */ \
-  OP(WindowRectanglesEXTImmediate)                             /* 564 */ \
-  OP(CreateGpuFenceINTERNAL)                                   /* 565 */ \
-  OP(WaitGpuFenceCHROMIUM)                                     /* 566 */ \
-  OP(DestroyGpuFenceCHROMIUM)                                  /* 567 */ \
-  OP(SetReadbackBufferShadowAllocationINTERNAL)                /* 568 */ \
-  OP(FramebufferTextureMultiviewOVR)                           /* 569 */ \
-  OP(MaxShaderCompilerThreadsKHR)                              /* 570 */ \
-  OP(CreateAndTexStorage2DSharedImageINTERNALImmediate)        /* 571 */ \
-  OP(BeginSharedImageAccessDirectCHROMIUM)                     /* 572 */ \
-  OP(EndSharedImageAccessDirectCHROMIUM)                       /* 573 */ \
-  OP(BeginBatchReadAccessSharedImageCHROMIUM)                  /* 574 */ \
-  OP(EndBatchReadAccessSharedImageCHROMIUM)                    /* 575 */ \
-  OP(EnableiOES)                                               /* 576 */ \
-  OP(DisableiOES)                                              /* 577 */ \
-  OP(BlendEquationiOES)                                        /* 578 */ \
-  OP(BlendEquationSeparateiOES)                                /* 579 */ \
-  OP(BlendFunciOES)                                            /* 580 */ \
-  OP(BlendFuncSeparateiOES)                                    /* 581 */ \
-  OP(ColorMaskiOES)                                            /* 582 */ \
-  OP(IsEnablediOES)                                            /* 583 */
+  OP(PostSubBufferCHROMIUM)                                    /* 535 */ \
+  OP(CopyTextureCHROMIUM)                                      /* 536 */ \
+  OP(CopySubTextureCHROMIUM)                                   /* 537 */ \
+  OP(DrawArraysInstancedANGLE)                                 /* 538 */ \
+  OP(DrawArraysInstancedBaseInstanceANGLE)                     /* 539 */ \
+  OP(DrawElementsInstancedANGLE)                               /* 540 */ \
+  OP(DrawElementsInstancedBaseVertexBaseInstanceANGLE)         /* 541 */ \
+  OP(VertexAttribDivisorANGLE)                                 /* 542 */ \
+  OP(ProduceTextureDirectCHROMIUMImmediate)                    /* 543 */ \
+  OP(CreateAndConsumeTextureINTERNALImmediate)                 /* 544 */ \
+  OP(BindUniformLocationCHROMIUMBucket)                        /* 545 */ \
+  OP(TraceBeginCHROMIUM)                                       /* 546 */ \
+  OP(TraceEndCHROMIUM)                                         /* 547 */ \
+  OP(DiscardFramebufferEXTImmediate)                           /* 548 */ \
+  OP(LoseContextCHROMIUM)                                      /* 549 */ \
+  OP(DrawBuffersEXTImmediate)                                  /* 550 */ \
+  OP(DiscardBackbufferCHROMIUM)                                /* 551 */ \
+  OP(ScheduleOverlayPlaneCHROMIUM)                             /* 552 */ \
+  OP(ScheduleCALayerSharedStateCHROMIUM)                       /* 553 */ \
+  OP(ScheduleCALayerCHROMIUM)                                  /* 554 */ \
+  OP(ScheduleCALayerInUseQueryCHROMIUMImmediate)               /* 555 */ \
+  OP(CommitOverlayPlanesCHROMIUM)                              /* 556 */ \
+  OP(FlushDriverCachesCHROMIUM)                                /* 557 */ \
+  OP(ScheduleDCLayerCHROMIUM)                                  /* 558 */ \
+  OP(SetActiveURLCHROMIUM)                                     /* 559 */ \
+  OP(ContextVisibilityHintCHROMIUM)                            /* 560 */ \
+  OP(CoverageModulationCHROMIUM)                               /* 561 */ \
+  OP(BlendBarrierKHR)                                          /* 562 */ \
+  OP(BindFragDataLocationIndexedEXTBucket)                     /* 563 */ \
+  OP(BindFragDataLocationEXTBucket)                            /* 564 */ \
+  OP(GetFragDataIndexEXT)                                      /* 565 */ \
+  OP(SwapBuffersWithBoundsCHROMIUMImmediate)                   /* 566 */ \
+  OP(SetDrawRectangleCHROMIUM)                                 /* 567 */ \
+  OP(SetEnableDCLayersCHROMIUM)                                /* 568 */ \
+  OP(InitializeDiscardableTextureCHROMIUM)                     /* 569 */ \
+  OP(UnlockDiscardableTextureCHROMIUM)                         /* 570 */ \
+  OP(LockDiscardableTextureCHROMIUM)                           /* 571 */ \
+  OP(TexStorage2DImageCHROMIUM)                                /* 572 */ \
+  OP(SetColorSpaceMetadataCHROMIUM)                            /* 573 */ \
+  OP(WindowRectanglesEXTImmediate)                             /* 574 */ \
+  OP(CreateGpuFenceINTERNAL)                                   /* 575 */ \
+  OP(WaitGpuFenceCHROMIUM)                                     /* 576 */ \
+  OP(DestroyGpuFenceCHROMIUM)                                  /* 577 */ \
+  OP(SetReadbackBufferShadowAllocationINTERNAL)                /* 578 */ \
+  OP(FramebufferTextureMultiviewOVR)                           /* 579 */ \
+  OP(MaxShaderCompilerThreadsKHR)                              /* 580 */ \
+  OP(CreateAndTexStorage2DSharedImageINTERNALImmediate)        /* 581 */ \
+  OP(BeginSharedImageAccessDirectCHROMIUM)                     /* 582 */ \
+  OP(EndSharedImageAccessDirectCHROMIUM)                       /* 583 */ \
+  OP(BeginBatchReadAccessSharedImageCHROMIUM)                  /* 584 */ \
+  OP(EndBatchReadAccessSharedImageCHROMIUM)                    /* 585 */ \
+  OP(EnableiOES)                                               /* 586 */ \
+  OP(DisableiOES)                                              /* 587 */ \
+  OP(BlendEquationiOES)                                        /* 588 */ \
+  OP(BlendEquationSeparateiOES)                                /* 589 */ \
+  OP(BlendFunciOES)                                            /* 590 */ \
+  OP(BlendFuncSeparateiOES)                                    /* 591 */ \
+  OP(ColorMaskiOES)                                            /* 592 */ \
+  OP(IsEnablediOES)                                            /* 593 */
 
 enum CommandId {
   kOneBeforeStartPoint =
diff --git gpu/command_buffer/common/gles2_cmd_utils_implementation_autogen.h gpu/command_buffer/common/gles2_cmd_utils_implementation_autogen.h
index 56c9ef320403c..e67cd3ad69538 100644
--- gpu/command_buffer/common/gles2_cmd_utils_implementation_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_utils_implementation_autogen.h
@@ -612,6 +612,10 @@ static const GLES2Util::EnumToString enum_to_string_table[] = {
         0x0F,
         "GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV",
     },
+    {
+        0x1,
+        "GL_CA_LAYER_EDGE_LEFT_CHROMIUM",
+    },
     {
         0x10,
         "GL_SMOOTH_CUBIC_CURVE_TO_NV",
@@ -856,6 +860,10 @@ static const GLES2Util::EnumToString enum_to_string_table[] = {
         0x1F03,
         "GL_EXTENSIONS",
     },
+    {
+        0x2,
+        "GL_CA_LAYER_EDGE_RIGHT_CHROMIUM",
+    },
     {
         0x20,
         "GL_GLYPH_VERTICAL_BEARING_X_BIT_NV",
@@ -956,6 +964,10 @@ static const GLES2Util::EnumToString enum_to_string_table[] = {
         0x300E,
         "GL_CONTEXT_LOST",
     },
+    {
+        0x4,
+        "GL_CA_LAYER_EDGE_BOTTOM_CHROMIUM",
+    },
     {
         0x40,
         "GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV",
@@ -1024,6 +1036,10 @@ static const GLES2Util::EnumToString enum_to_string_table[] = {
         0x78FD,
         "GL_RGB_YCBCR_P010_CHROMIUM",
     },
+    {
+        0x8,
+        "GL_CA_LAYER_EDGE_TOP_CHROMIUM",
+    },
     {
         0x80,
         "GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV",
@@ -5284,6 +5300,30 @@ static const GLES2Util::EnumToString enum_to_string_table[] = {
         0x9244,
         "GL_BIND_GENERATES_RESOURCE_CHROMIUM",
     },
+    {
+        0x9245,
+        "GL_OVERLAY_TRANSFORM_NONE_CHROMIUM",
+    },
+    {
+        0x9246,
+        "GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM",
+    },
+    {
+        0x9247,
+        "GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM",
+    },
+    {
+        0x9248,
+        "GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM",
+    },
+    {
+        0x9249,
+        "GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM",
+    },
+    {
+        0x924A,
+        "GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM",
+    },
     {
         0x9250,
         "GL_SHADER_BINARY_DMP",
diff --git gpu/command_buffer/common/swap_buffers_flags.h gpu/command_buffer/common/swap_buffers_flags.h
index cc096891d1103..16e42412ea7f5 100644
--- gpu/command_buffer/common/swap_buffers_flags.h
+++ gpu/command_buffer/common/swap_buffers_flags.h
@@ -7,7 +7,9 @@
 
 namespace gpu {
 
-// Flags for calling glSwapBuffers with Chromium GLES2 command buffer.
+// Flags for calling glSwapBuffers, glPostiSubBufferCHROMIUM,
+// glSwapBuffersWithBoundsCHROMIUM and glCommitOverlayPlanesCHROMIUM with
+// Chromium GLES2 command buffer.
 class SwapBuffersFlags {
  public:
   enum : uint32_t {
diff --git gpu/command_buffer/gles2_cmd_buffer_functions.txt gpu/command_buffer/gles2_cmd_buffer_functions.txt
index 624c7317a46cb..fbb9abf3e6fa5 100644
--- gpu/command_buffer/gles2_cmd_buffer_functions.txt
+++ gpu/command_buffer/gles2_cmd_buffer_functions.txt
@@ -312,6 +312,7 @@ GL_APICALL void         GL_APIENTRY glGetTransformFeedbackVaryingsCHROMIUM (GLid
 GL_APICALL void         GL_APIENTRY glGetUniformsES3CHROMIUM (GLidProgram program, GLsizeiNotNegative bufsize, GLsizei* size, void* info);
 GL_APICALL void         GL_APIENTRY glDescheduleUntilFinishedCHROMIUM (void);
 GL_APICALL void         GL_APIENTRY glGetTranslatedShaderSourceANGLE (GLidShader shader, GLsizeiNotNegative bufsize, GLsizeiOptional* length, char* source);
+GL_APICALL void         GL_APIENTRY glPostSubBufferCHROMIUM (GLuint64 swap_id, GLint x, GLint y, GLint width, GLint height, GLbitfieldSwapBuffersFlags flags = 0);
 GL_APICALL void         GL_APIENTRY glCopyTextureCHROMIUM (GLuint source_id, GLint source_level, GLenumTextureTarget dest_target, GLuint dest_id, GLint dest_level, GLintTextureInternalFormat internalformat, GLenumPixelType dest_type, GLboolean unpack_flip_y, GLboolean unpack_premultiply_alpha, GLboolean unpack_unmultiply_alpha);
 GL_APICALL void         GL_APIENTRY glCopySubTextureCHROMIUM (GLuint source_id, GLint source_level, GLenumTextureTarget dest_target, GLuint dest_id, GLint dest_level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, GLboolean unpack_flip_y, GLboolean unpack_premultiply_alpha, GLboolean unpack_unmultiply_alpha);
 GL_APICALL void         GL_APIENTRY glDrawArraysInstancedANGLE (GLenumDrawMode mode, GLint first, GLsizei count, GLsizei primcount);
@@ -329,8 +330,14 @@ GL_APICALL void         GL_APIENTRY glDiscardFramebufferEXT (GLenumFramebufferTa
 GL_APICALL void         GL_APIENTRY glLoseContextCHROMIUM (GLenumResetStatus current, GLenumResetStatus other);
 GL_APICALL void         GL_APIENTRY glDrawBuffersEXT (GLsizei count, const GLenum* bufs);
 GL_APICALL void         GL_APIENTRY glDiscardBackbufferCHROMIUM (void);
+GL_APICALL void         GL_APIENTRY glScheduleOverlayPlaneCHROMIUM (GLint plane_z_order, GLenum plane_transform, GLuint overlay_texture_id, GLint bounds_x, GLint bounds_y, GLint bounds_width, GLint bounds_height, GLfloat uv_x, GLfloat uv_y, GLfloat uv_width, GLfloat uv_height, GLboolean enable_blend, GLuint gpu_fence_id);
+GL_APICALL void         GL_APIENTRY glScheduleCALayerSharedStateCHROMIUM (GLfloat opacity, GLboolean is_clipped, const GLfloat* clip_rect, const GLfloat* rounded_corner_bounds, GLint sorting_context_id, const GLfloat* transform);
+GL_APICALL void         GL_APIENTRY glScheduleCALayerCHROMIUM (GLuint contents_texture_id, const GLfloat* contents_rect, GLuint background_color, GLuint edge_aa_mask, const GLfloat* bounds_rect, GLuint filter);
+GL_APICALL void         GL_APIENTRY glScheduleCALayerInUseQueryCHROMIUM (GLsizei count, const GLuint* textures);
+GL_APICALL void         GL_APIENTRY glCommitOverlayPlanesCHROMIUM (GLuint64 swap_id, GLbitfieldSwapBuffersFlags flags = 0);
 GL_APICALL void         GL_APIENTRY glFlushDriverCachesCHROMIUM (void);
 GL_APICALL GLuint       GL_APIENTRY glGetLastFlushIdCHROMIUM (void);
+GL_APICALL void         GL_APIENTRY glScheduleDCLayerCHROMIUM (GLuint texture_0, GLuint texture_1, GLint z_order, GLint content_x, GLint content_y, GLint content_width, GLint content_height, GLint quad_x, GLint quad_y, GLint quad_width, GLint quad_height, GLfloat transform_c1r1, GLfloat transform_c2r1, GLfloat transform_c1r2, GLfloat transform_c2r2, GLfloat transform_tx, GLfloat transform_ty, GLboolean is_clipped, GLint clip_x, GLint clip_y, GLint clip_width, GLint clip_height, GLuint protected_video_type);
 GL_APICALL void         GL_APIENTRY glSetActiveURLCHROMIUM (const char* url);
 
 // Extension CHROMIUM_context_visibility_hint
@@ -350,6 +357,14 @@ GL_APICALL void         GL_APIENTRY glBindFragDataLocationIndexedEXT (GLidProgra
 GL_APICALL void         GL_APIENTRY glBindFragDataLocationEXT (GLidProgram program, GLuint colorNumber, const char* name);
 GL_APICALL GLint        GL_APIENTRY glGetFragDataIndexEXT (GLidProgram program, const char* name);
 
+GL_APICALL void         GL_APIENTRY glSwapBuffersWithBoundsCHROMIUM (GLuint64 swap_id, GLsizei count, const GLint* rects, GLbitfieldSwapBuffersFlags flags = 0);
+
+// Extension CHROMIUM_set_draw_rectangle
+GL_APICALL void         GL_APIENTRY glSetDrawRectangleCHROMIUM (GLint x, GLint y, GLint width, GLint height);
+
+// Extension CHROMIUM_dc_overlays
+GL_APICALL void         GL_APIENTRY glSetEnableDCLayersCHROMIUM (GLboolean enabled);
+
 // Extension CHROMIUM_discardable_textures
 GL_APICALL void         GL_APIENTRY glInitializeDiscardableTextureCHROMIUM (GLuint texture_id);
 GL_APICALL void         GL_APIENTRY glUnlockDiscardableTextureCHROMIUM (GLuint texture_id);
diff --git gpu/command_buffer/service/decoder_client.h gpu/command_buffer/service/decoder_client.h
index 2d87a9139fe71..b6bd464d725d7 100644
--- gpu/command_buffer/service/decoder_client.h
+++ gpu/command_buffer/service/decoder_client.h
@@ -47,7 +47,8 @@ class GPU_EXPORT DecoderClient {
   // because the fence completed.
   virtual void OnRescheduleAfterFinished() = 0;
 
-  // Called when SwapBuffers is called.
+  // Called when SwapBuffers, PostSubBufferCHROMIUM,
+  // SwapBuffersWithBoundsCHROMIUM or CommitOverlayPlanesCHROMIUM is called.
   virtual void OnSwapBuffers(uint64_t swap_id, uint32_t flags) = 0;
 
   // Notifies the client that the shared GrContext may have been used by this
diff --git gpu/command_buffer/service/gl_utils.cc gpu/command_buffer/service/gl_utils.cc
index edf82c265246c..8e8109d7e8aea 100644
--- gpu/command_buffer/service/gl_utils.cc
+++ gpu/command_buffer/service/gl_utils.cc
@@ -1186,6 +1186,25 @@ GLenum GetTextureBindingQuery(GLenum texture_type) {
   }
 }
 
+gfx::OverlayTransform GetGFXOverlayTransform(GLenum plane_transform) {
+  switch (plane_transform) {
+    case GL_OVERLAY_TRANSFORM_NONE_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_NONE;
+    case GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_FLIP_HORIZONTAL;
+    case GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_FLIP_VERTICAL;
+    case GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_ROTATE_90;
+    case GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_ROTATE_180;
+    case GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM:
+      return gfx::OVERLAY_TRANSFORM_ROTATE_270;
+    default:
+      return gfx::OVERLAY_TRANSFORM_INVALID;
+  }
+}
+
 bool GetGFXBufferFormat(GLenum internal_format, gfx::BufferFormat* out_format) {
   switch (internal_format) {
     case GL_RGBA8_OES:
diff --git gpu/command_buffer/service/gles2_cmd_decoder.cc gpu/command_buffer/service/gles2_cmd_decoder.cc
index 2b89619fd4071..6835f8991ff89 100644
--- gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -1114,11 +1114,19 @@ class GLES2DecoderImpl : public GLES2Decoder,
   // Wrapper for SwapBuffers.
   void DoSwapBuffers(uint64_t swap_id, GLbitfield flags);
 
+  // Wrapper for SwapBuffersWithBoundsCHROMIUM.
+  void DoSwapBuffersWithBoundsCHROMIUM(uint64_t swap_id,
+                                       GLsizei count,
+                                       const volatile GLint* rects,
+                                       GLbitfield flags);
+
   // Callback for async SwapBuffers.
   void FinishAsyncSwapBuffers(uint64_t swap_id,
                               gfx::SwapCompletionResult result);
   void FinishSwapBuffers(gfx::SwapResult result);
 
+  void DoCommitOverlayPlanes(uint64_t swap_id, GLbitfield flags);
+
   // Wrapper for CopyTexSubImage2D.
   void DoCopyTexSubImage2D(
       GLenum target,
@@ -1230,9 +1238,36 @@ class GLES2DecoderImpl : public GLES2Decoder,
 
   void DoFlushDriverCachesCHROMIUM(void);
 
+  void DoScheduleCALayerInUseQueryCHROMIUM(GLsizei count,
+                                           const volatile GLuint* textures);
+
   void DoFlushMappedBufferRange(
       GLenum target, GLintptr offset, GLsizeiptr size);
 
+  void DoScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                 GLuint texture_1,
+                                 GLint z_order,
+                                 GLint content_x,
+                                 GLint content_y,
+                                 GLint content_width,
+                                 GLint content_height,
+                                 GLint quad_x,
+                                 GLint quad_y,
+                                 GLint quad_width,
+                                 GLint quad_height,
+                                 GLfloat transform_c1r1,
+                                 GLfloat transform_c2r1,
+                                 GLfloat transform_c1r2,
+                                 GLfloat transform_c2r2,
+                                 GLfloat transform_tx,
+                                 GLfloat transform_ty,
+                                 GLboolean is_clipped,
+                                 GLint clip_x,
+                                 GLint clip_y,
+                                 GLint clip_width,
+                                 GLint clip_height,
+                                 GLuint protected_video_type);
+
   // Creates a Program for the given program.
   Program* CreateProgram(GLuint client_id, GLuint service_id) {
     return program_manager()->CreateProgram(client_id, service_id);
@@ -1923,6 +1958,11 @@ class GLES2DecoderImpl : public GLES2Decoder,
   void DoMultiDrawBeginCHROMIUM(GLsizei drawcount);
   void DoMultiDrawEndCHROMIUM();
 
+  // Wrapper for glSetDrawRectangleCHROMIUM
+  void DoSetDrawRectangleCHROMIUM(GLint x, GLint y, GLint width, GLint height);
+
+  void DoSetEnableDCLayersCHROMIUM(GLboolean enable);
+
   // Wrapper for glReadBuffer
   void DoReadBuffer(GLenum src);
 
@@ -2462,6 +2502,10 @@ class GLES2DecoderImpl : public GLES2Decoder,
   // using GL_RGBA and glColorMask.
   bool ChromiumImageNeedsRGBEmulation();
 
+  // The GL_CHROMIUM_schedule_ca_layer extension requires that SwapBuffers and
+  // equivalent functions reset shared state.
+  void ClearScheduleCALayerState();
+
   // Helper method to call glClear workaround.
   void ClearFramebufferForWorkaround(GLbitfield mask);
 
@@ -2774,6 +2818,8 @@ class GLES2DecoderImpl : public GLES2Decoder,
 
   SamplerState default_sampler_state_;
 
+  std::unique_ptr<CALayerSharedState> ca_layer_shared_state_;
+
   // All currently outstanding AbstractTextures that we've created.
   std::set<ValidatingAbstractTextureImpl*> abstract_textures_;
 
@@ -9818,6 +9864,58 @@ void GLES2DecoderImpl::DoLinkProgram(GLuint program_id) {
   ExitCommandProcessingEarly();
 }
 
+void GLES2DecoderImpl::DoSetDrawRectangleCHROMIUM(GLint x,
+                                                  GLint y,
+                                                  GLint width,
+                                                  GLint height) {
+  Framebuffer* framebuffer = GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER);
+  if (framebuffer) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetDrawRectangleCHROMIUM",
+                       "framebuffer must not be bound");
+    return;
+  }
+  if (!supports_dc_layers_) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetDrawRectangleCHROMIUM",
+                       "surface doesn't support SetDrawRectangle");
+    return;
+  }
+  gfx::Rect rect(x, y, width, height);
+  if (!surface_->SetDrawRectangle(rect)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetDrawRectangleCHROMIUM",
+                       "failed on surface");
+    // If SetDrawRectangle failed, we may not have a current context any
+    // more, make sure to report lost context.
+    LOG(ERROR) << "Context lost because SetDrawRectangleCHROMIUM failed.";
+    MarkContextLost(error::kUnknown);
+    group_->LoseContexts(error::kUnknown);
+    return;
+  }
+  OnFboChanged();
+}
+
+void GLES2DecoderImpl::DoSetEnableDCLayersCHROMIUM(GLboolean enable) {
+  Framebuffer* framebuffer = GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER);
+  if (framebuffer) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetEnableDCLayersCHROMIUM",
+                       "framebuffer must not be bound");
+    return;
+  }
+  if (!supports_dc_layers_) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetEnableDCLayersCHROMIUM",
+                       "surface doesn't support SetEnableDCLayers");
+    return;
+  }
+  if (!surface_->SetEnableDCLayers(!!enable)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSetEnableDCLayersCHROMIUM",
+                       "failed on surface");
+    // If SetEnableDCLayers failed, we may not have a current context any
+    // more, make sure to report lost context.
+    LOG(ERROR) << "Context lost because SetEnableDCLayers failed.";
+    MarkContextLost(error::kUnknown);
+    group_->LoseContexts(error::kUnknown);
+  }
+}
+
 void GLES2DecoderImpl::DoReadBuffer(GLenum src) {
   Framebuffer* framebuffer = GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER);
   if (framebuffer) {
@@ -13546,6 +13644,231 @@ error::Error GLES2DecoderImpl::HandlePixelStorei(
   return error::kNoError;
 }
 
+void GLES2DecoderImpl::DoSwapBuffersWithBoundsCHROMIUM(
+    uint64_t swap_id,
+    GLsizei count,
+    const volatile GLint* rects,
+    GLbitfield flags) {
+  TRACE_EVENT0("gpu", "GLES2DecoderImpl::SwapBuffersWithBoundsCHROMIUM");
+  if (!supports_swap_buffers_with_bounds_) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glSwapBuffersWithBoundsCHROMIUM",
+                       "command not supported by surface");
+    return;
+  }
+  bool is_tracing;
+  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT("gpu.debug"),
+                                     &is_tracing);
+  if (is_tracing) {
+    bool is_offscreen = !!offscreen_target_frame_buffer_.get();
+    ScopedFramebufferBinder binder(this, GetBoundDrawFramebufferServiceId());
+    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(
+        is_offscreen ? offscreen_size_ : surface_->GetSize());
+  }
+
+  ClearScheduleCALayerState();
+
+  std::vector<gfx::Rect> bounds(count);
+  for (GLsizei i = 0; i < count; ++i) {
+    bounds[i] = gfx::Rect(rects[i * 4 + 0], rects[i * 4 + 1], rects[i * 4 + 2],
+                          rects[i * 4 + 3]);
+  }
+  client()->OnSwapBuffers(swap_id, flags);
+  FinishSwapBuffers(surface_->SwapBuffersWithBounds(bounds, base::DoNothing()));
+}
+
+error::Error GLES2DecoderImpl::HandlePostSubBufferCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::PostSubBufferCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::PostSubBufferCHROMIUM*>(
+          cmd_data);
+  TRACE_EVENT0("gpu", "GLES2DecoderImpl::HandlePostSubBufferCHROMIUM");
+  if (!supports_post_sub_buffer_) {
+    LOCAL_SET_GL_ERROR(
+        GL_INVALID_OPERATION,
+        "glPostSubBufferCHROMIUM", "command not supported by surface");
+    return error::kNoError;
+  }
+  bool is_tracing;
+  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT("gpu.debug"),
+                                     &is_tracing);
+  if (is_tracing) {
+    bool is_offscreen = !!offscreen_target_frame_buffer_.get();
+    ScopedFramebufferBinder binder(this, GetBoundDrawFramebufferServiceId());
+    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(
+        is_offscreen ? offscreen_size_ : surface_->GetSize());
+  }
+
+  ClearScheduleCALayerState();
+
+  if (supports_async_swap_) {
+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(
+        "gpu", "AsyncSwapBuffers",
+        TRACE_ID_WITH_SCOPE("AsyncSwapBuffers", c.swap_id()));
+
+    client()->OnSwapBuffers(c.swap_id(), c.flags);
+    surface_->PostSubBufferAsync(
+        c.x, c.y, c.width, c.height,
+        base::BindOnce(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
+                       weak_ptr_factory_.GetWeakPtr(), c.swap_id()),
+        base::DoNothing());
+  } else {
+    client()->OnSwapBuffers(c.swap_id(), c.flags);
+    FinishSwapBuffers(surface_->PostSubBuffer(c.x, c.y, c.width, c.height,
+                                              base::DoNothing()));
+  }
+
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleScheduleOverlayPlaneCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleOverlayPlaneCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleOverlayPlaneCHROMIUM*>(
+          cmd_data);
+  TextureRef* ref = texture_manager()->GetTexture(c.overlay_texture_id);
+  if (!ref) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
+                       "glScheduleOverlayPlaneCHROMIUM",
+                       "unknown texture");
+    return error::kNoError;
+  }
+  Texture::ImageState image_state;
+  gl::GLImage* image =
+      ref->texture()->GetLevelImage(ref->texture()->target(), 0, &image_state);
+  if (!image) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
+                       "glScheduleOverlayPlaneCHROMIUM",
+                       "unsupported texture format");
+    return error::kNoError;
+  }
+  gfx::OverlayTransform transform = GetGFXOverlayTransform(c.plane_transform);
+  if (transform == gfx::OVERLAY_TRANSFORM_INVALID) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM,
+                       "glScheduleOverlayPlaneCHROMIUM",
+                       "invalid transform enum");
+    return error::kNoError;
+  }
+  GLuint gpu_fence_id = static_cast<GLuint>(c.gpu_fence_id);
+  std::unique_ptr<gfx::GpuFence> gpu_fence;
+  if (gpu_fence_id > 0) {
+    gpu_fence = GetGpuFenceManager()->GetGpuFence(gpu_fence_id);
+    if (!gpu_fence) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, "glScheduleOverlayPlaneCHROMIUM",
+                         "unknown fence");
+      return error::kNoError;
+    }
+  }
+  if (!surface_->ScheduleOverlayPlane(
+          image, std::move(gpu_fence),
+          gfx::OverlayPlaneData(
+              c.plane_z_order, transform,
+              gfx::RectF(c.bounds_x, c.bounds_y, c.bounds_width,
+                         c.bounds_height),
+              gfx::RectF(c.uv_x, c.uv_y, c.uv_width, c.uv_height),
+              c.enable_blend,
+              /*damage_rect=*/gfx::Rect(), /*opacity*/ 1.0f,
+              gfx::OverlayPriorityHint::kNone,
+              /*rounded_corners*/ gfx::RRectF(), image->color_space(),
+              /*hdr_metadata=*/absl::nullopt))) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,
+                       "glScheduleOverlayPlaneCHROMIUM",
+                       "failed to schedule overlay");
+  }
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleScheduleCALayerSharedStateCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerSharedStateCHROMIUM& c =
+      *static_cast<
+          const volatile gles2::cmds::ScheduleCALayerSharedStateCHROMIUM*>(
+          cmd_data);
+
+  // 4 for |clip_rect|, 5 for |rounded_corner_bounds|, 16 for |transform|.
+  const GLfloat* mem = GetSharedMemoryAs<const GLfloat*>(c.shm_id, c.shm_offset,
+                                                         25 * sizeof(GLfloat));
+  if (!mem) {
+    return error::kOutOfBounds;
+  }
+  gfx::RectF clip_rect(mem[0], mem[1], mem[2], mem[3]);
+  gfx::RRectF rounded_corner_bounds(mem[4], mem[5], mem[6], mem[7], mem[8]);
+  gfx::Transform transform(mem[9], mem[13], mem[17], mem[21], mem[10], mem[14],
+                           mem[18], mem[22], mem[11], mem[15], mem[19], mem[23],
+                           mem[12], mem[16], mem[20], mem[24]);
+  ca_layer_shared_state_ = std::make_unique<CALayerSharedState>();
+  ca_layer_shared_state_->opacity = c.opacity;
+  ca_layer_shared_state_->is_clipped = c.is_clipped ? true : false;
+  ca_layer_shared_state_->clip_rect = gfx::ToEnclosingRect(clip_rect);
+  ca_layer_shared_state_->rounded_corner_bounds = rounded_corner_bounds;
+  ca_layer_shared_state_->sorting_context_id = c.sorting_context_id;
+  ca_layer_shared_state_->transform = transform;
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleScheduleCALayerCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleCALayerCHROMIUM*>(
+          cmd_data);
+  GLuint filter = c.filter;
+  if (filter != GL_NEAREST && filter != GL_LINEAR) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleCALayerCHROMIUM",
+                       "invalid filter");
+    return error::kNoError;
+  }
+
+  if (!ca_layer_shared_state_) {
+    LOCAL_SET_GL_ERROR(
+        GL_INVALID_OPERATION, "glScheduleCALayerCHROMIUM",
+        "glScheduleCALayerSharedStateCHROMIUM has not been called");
+    return error::kNoError;
+  }
+
+  gl::GLImage* image = nullptr;
+  GLuint contents_texture_id = c.contents_texture_id;
+  if (contents_texture_id) {
+    TextureRef* ref = texture_manager()->GetTexture(contents_texture_id);
+    if (!ref) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleCALayerCHROMIUM",
+                         "unknown texture");
+      return error::kNoError;
+    }
+    Texture::ImageState image_state;
+    image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,
+                                          &image_state);
+    if (!image) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleCALayerCHROMIUM",
+                         "unsupported texture format");
+      return error::kNoError;
+    }
+  }
+
+  const GLfloat* mem = GetSharedMemoryAs<const GLfloat*>(c.shm_id, c.shm_offset,
+                                                         8 * sizeof(GLfloat));
+  if (!mem) {
+    return error::kOutOfBounds;
+  }
+  gfx::RectF contents_rect(mem[0], mem[1], mem[2], mem[3]);
+  gfx::RectF bounds_rect(mem[4], mem[5], mem[6], mem[7]);
+
+  ui::CARendererLayerParams params = ui::CARendererLayerParams(
+      ca_layer_shared_state_->is_clipped, ca_layer_shared_state_->clip_rect,
+      ca_layer_shared_state_->rounded_corner_bounds,
+      ca_layer_shared_state_->sorting_context_id,
+      ca_layer_shared_state_->transform, image, contents_rect,
+      gfx::ToEnclosingRect(bounds_rect), c.background_color, c.edge_aa_mask,
+      ca_layer_shared_state_->opacity, filter, gfx::ProtectedVideoType::kClear);
+  if (!surface_->ScheduleCALayer(params)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glScheduleCALayerCHROMIUM",
+                       "failed to schedule CALayer");
+  }
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderImpl::HandleSetColorSpaceMetadataCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -13579,6 +13902,34 @@ error::Error GLES2DecoderImpl::HandleSetColorSpaceMetadataCHROMIUM(
   return error::kNoError;
 }
 
+void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei count,
+    const volatile GLuint* textures) {
+  std::vector<gl::GLSurface::CALayerInUseQuery> queries;
+  queries.reserve(count);
+  for (GLsizei i = 0; i < count; ++i) {
+    gl::GLImage* image = nullptr;
+    GLuint texture_id = textures[i];
+    if (texture_id) {
+      // If a |texture_id| is invalid (due to a client error), report that it
+      // is not in use. Failing the GL call can result in compositor hangs.
+      // https://crbug.com/1120795
+      TextureRef* ref = texture_manager()->GetTexture(texture_id);
+      if (ref) {
+        Texture::ImageState image_state;
+        image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,
+                                              &image_state);
+      }
+    }
+    gl::GLSurface::CALayerInUseQuery query;
+    query.image = image;
+    query.texture = texture_id;
+    queries.push_back(query);
+  }
+
+  surface_->ScheduleCALayerInUseQuery(std::move(queries));
+}
+
 error::Error GLES2DecoderImpl::GetAttribLocationHelper(
     GLuint client_id,
     uint32_t location_shm_id,
@@ -13908,6 +14259,8 @@ error::Error GLES2DecoderImpl::HandleGetString(uint32_t immediate_data_size,
           extension_set.erase(
               kWEBGLMultiDrawInstancedBaseVertexBaseInstanceExtension);
       }
+      if (supports_post_sub_buffer_)
+        extension_set.insert("GL_CHROMIUM_post_sub_buffer");
       extensions = gfx::MakeExtensionString(extension_set);
       str = extensions.c_str();
       break;
@@ -16632,6 +16985,8 @@ void GLES2DecoderImpl::DoSwapBuffers(uint64_t swap_id, GLbitfield flags) {
         is_offscreen ? offscreen_size_ : surface_->GetSize());
   }
 
+  ClearScheduleCALayerState();
+
   // If offscreen then don't actually SwapBuffers to the display. Just copy
   // the rendered frame to another frame buffer.
   if (is_offscreen) {
@@ -16747,7 +17102,8 @@ void GLES2DecoderImpl::FinishAsyncSwapBuffers(
 
 void GLES2DecoderImpl::FinishSwapBuffers(gfx::SwapResult result) {
   if (result == gfx::SwapResult::SWAP_FAILED) {
-    // If SwapBuffers failed, we may not have a current context any more.
+    // If SwapBuffers/SwapBuffersWithBounds/PostSubBuffer failed, we may not
+    // have a current context any more.
     LOG(ERROR) << "Context lost because SwapBuffers failed.";
     if (!context_->IsCurrent(surface_.get()) || !CheckResetStatus()) {
       MarkContextLost(error::kUnknown);
@@ -16762,6 +17118,27 @@ void GLES2DecoderImpl::FinishSwapBuffers(gfx::SwapResult result) {
   }
 }
 
+void GLES2DecoderImpl::DoCommitOverlayPlanes(uint64_t swap_id,
+                                             GLbitfield flags) {
+  TRACE_EVENT0("gpu", "GLES2DecoderImpl::DoCommitOverlayPlanes");
+  if (!supports_commit_overlay_planes_) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glCommitOverlayPlanes",
+                       "command not supported by surface");
+    return;
+  }
+  ClearScheduleCALayerState();
+  if (supports_async_swap_) {
+    client()->OnSwapBuffers(swap_id, flags);
+    surface_->CommitOverlayPlanesAsync(
+        base::BindOnce(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
+                       weak_ptr_factory_.GetWeakPtr(), swap_id),
+        base::DoNothing());
+  } else {
+    client()->OnSwapBuffers(swap_id, flags);
+    FinishSwapBuffers(surface_->CommitOverlayPlanes(base::DoNothing()));
+  }
+}
+
 error::Error GLES2DecoderImpl::HandleEnableFeatureCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -19306,6 +19683,83 @@ void GLES2DecoderImpl::DoFlushMappedBufferRange(
   api()->glFlushMappedBufferRangeFn(target, offset, size);
 }
 
+void GLES2DecoderImpl::DoScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                                 GLuint texture_1,
+                                                 GLint z_order,
+                                                 GLint content_x,
+                                                 GLint content_y,
+                                                 GLint content_width,
+                                                 GLint content_height,
+                                                 GLint quad_x,
+                                                 GLint quad_y,
+                                                 GLint quad_width,
+                                                 GLint quad_height,
+                                                 GLfloat transform_c1r1,
+                                                 GLfloat transform_c2r1,
+                                                 GLfloat transform_c1r2,
+                                                 GLfloat transform_c2r2,
+                                                 GLfloat transform_tx,
+                                                 GLfloat transform_ty,
+                                                 GLboolean is_clipped,
+                                                 GLint clip_x,
+                                                 GLint clip_y,
+                                                 GLint clip_width,
+                                                 GLint clip_height,
+                                                 GLuint protected_video_type) {
+  if (protected_video_type >
+      static_cast<GLuint>(gfx::ProtectedVideoType::kMaxValue)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleDCLayerCHROMIUM",
+                       "invalid protected video type");
+    return;
+  }
+
+  if (!texture_0) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleDCLayerCHROMIUM",
+                       "invalid texture");
+    return;
+  }
+
+  std::unique_ptr<ui::DCRendererLayerParams> params =
+      std::make_unique<ui::DCRendererLayerParams>();
+  GLuint texture_ids[] = {texture_0, texture_1};
+  size_t i = 0;
+  for (GLuint texture_id : texture_ids) {
+    if (!texture_id)
+      break;
+    TextureRef* ref = texture_manager()->GetTexture(texture_id);
+    if (!ref) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleDCLayerCHROMIUM",
+                         "unknown texture");
+      return;
+    }
+    gl::GLImage* image =
+        ref->texture()->GetLevelImage(ref->texture()->target(), 0);
+    if (!image) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleDCLayerCHROMIUM",
+                         "unsupported texture format");
+      return;
+    }
+    params->images[i++] = scoped_refptr<gl::GLImage>(image);
+  }
+  params->z_order = z_order;
+  params->content_rect =
+      gfx::Rect(content_x, content_y, content_width, content_height);
+  params->quad_rect = gfx::Rect(quad_x, quad_y, quad_width, quad_height);
+  params->transform =
+      gfx::Transform(transform_c1r1, transform_c2r1, transform_c1r2,
+                     transform_c2r2, transform_tx, transform_ty);
+  if (is_clipped) {
+    params->clip_rect = gfx::Rect(clip_x, clip_y, clip_width, clip_height);
+  }
+  params->protected_video_type =
+      static_cast<gfx::ProtectedVideoType>(protected_video_type);
+
+  if (!surface_->ScheduleDCLayer(std::move(params))) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glScheduleDCLayerCHROMIUM",
+                       "failed to schedule DCLayer");
+  }
+}
+
 // Note that GL_LOST_CONTEXT is specific to GLES.
 // For desktop GL we have to query the reset status proactively.
 void GLES2DecoderImpl::OnContextLostError() {
@@ -19393,6 +19847,10 @@ bool GLES2DecoderImpl::ChromiumImageNeedsRGBEmulation() {
   return factory ? !factory->SupportsFormatRGB() : false;
 }
 
+void GLES2DecoderImpl::ClearScheduleCALayerState() {
+  ca_layer_shared_state_.reset();
+}
+
 void GLES2DecoderImpl::ClearFramebufferForWorkaround(GLbitfield mask) {
   ScopedGLErrorSuppressor suppressor("GLES2DecoderImpl::ClearWorkaround",
                                      error_state_.get());
diff --git gpu/command_buffer/service/gles2_cmd_decoder_autogen.h gpu/command_buffer/service/gles2_cmd_decoder_autogen.h
index 4ab29e8e783c8..55cd0ed3b181e 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_autogen.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_autogen.h
@@ -5120,6 +5120,52 @@ error::Error GLES2DecoderImpl::HandleDrawBuffersEXTImmediate(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderImpl::HandleScheduleCALayerInUseQueryCHROMIUMImmediate(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate& c =
+      *static_cast<const volatile gles2::cmds::
+                       ScheduleCALayerInUseQueryCHROMIUMImmediate*>(cmd_data);
+  GLsizei count = static_cast<GLsizei>(c.count);
+  uint32_t textures_size = 0;
+  if (count >= 0 &&
+      !GLES2Util::ComputeDataSize<GLuint, 1>(count, &textures_size)) {
+    return error::kOutOfBounds;
+  }
+  if (textures_size > immediate_data_size) {
+    return error::kOutOfBounds;
+  }
+  volatile const GLuint* textures = GetImmediateDataAs<volatile const GLuint*>(
+      c, textures_size, immediate_data_size);
+  if (count < 0) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glScheduleCALayerInUseQueryCHROMIUM",
+                       "count < 0");
+    return error::kNoError;
+  }
+  if (textures == nullptr) {
+    return error::kOutOfBounds;
+  }
+  DoScheduleCALayerInUseQueryCHROMIUM(count, textures);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleCommitOverlayPlanesCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CommitOverlayPlanesCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::CommitOverlayPlanesCHROMIUM*>(
+          cmd_data);
+  GLuint64 swap_id = c.swap_id();
+  GLbitfield flags = static_cast<GLbitfield>(c.flags);
+  if (!validators_->swap_buffers_flags.IsValid(flags)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCommitOverlayPlanesCHROMIUM",
+                       "flags GL_INVALID_VALUE");
+    return error::kNoError;
+  }
+  DoCommitOverlayPlanes(swap_id, flags);
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderImpl::HandleFlushDriverCachesCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -5127,6 +5173,44 @@ error::Error GLES2DecoderImpl::HandleFlushDriverCachesCHROMIUM(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderImpl::HandleScheduleDCLayerCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleDCLayerCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleDCLayerCHROMIUM*>(
+          cmd_data);
+  GLuint texture_0 = static_cast<GLuint>(c.texture_0);
+  GLuint texture_1 = static_cast<GLuint>(c.texture_1);
+  GLint z_order = static_cast<GLint>(c.z_order);
+  GLint content_x = static_cast<GLint>(c.content_x);
+  GLint content_y = static_cast<GLint>(c.content_y);
+  GLint content_width = static_cast<GLint>(c.content_width);
+  GLint content_height = static_cast<GLint>(c.content_height);
+  GLint quad_x = static_cast<GLint>(c.quad_x);
+  GLint quad_y = static_cast<GLint>(c.quad_y);
+  GLint quad_width = static_cast<GLint>(c.quad_width);
+  GLint quad_height = static_cast<GLint>(c.quad_height);
+  GLfloat transform_c1r1 = static_cast<GLfloat>(c.transform_c1r1);
+  GLfloat transform_c2r1 = static_cast<GLfloat>(c.transform_c2r1);
+  GLfloat transform_c1r2 = static_cast<GLfloat>(c.transform_c1r2);
+  GLfloat transform_c2r2 = static_cast<GLfloat>(c.transform_c2r2);
+  GLfloat transform_tx = static_cast<GLfloat>(c.transform_tx);
+  GLfloat transform_ty = static_cast<GLfloat>(c.transform_ty);
+  GLboolean is_clipped = static_cast<GLboolean>(c.is_clipped);
+  GLint clip_x = static_cast<GLint>(c.clip_x);
+  GLint clip_y = static_cast<GLint>(c.clip_y);
+  GLint clip_width = static_cast<GLint>(c.clip_width);
+  GLint clip_height = static_cast<GLint>(c.clip_height);
+  GLuint protected_video_type = static_cast<GLuint>(c.protected_video_type);
+  DoScheduleDCLayerCHROMIUM(
+      texture_0, texture_1, z_order, content_x, content_y, content_width,
+      content_height, quad_x, quad_y, quad_width, quad_height, transform_c1r1,
+      transform_c2r1, transform_c1r2, transform_c2r2, transform_tx,
+      transform_ty, is_clipped, clip_x, clip_y, clip_width, clip_height,
+      protected_video_type);
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderImpl::HandleContextVisibilityHintCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -5172,6 +5256,67 @@ error::Error GLES2DecoderImpl::HandleBlendBarrierKHR(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderImpl::HandleSwapBuffersWithBoundsCHROMIUMImmediate(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate& c =
+      *static_cast<
+          const volatile gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate*>(
+          cmd_data);
+  GLuint64 swap_id = c.swap_id();
+  GLsizei count = static_cast<GLsizei>(c.count);
+  uint32_t rects_size = 0;
+  if (count >= 0 && !GLES2Util::ComputeDataSize<GLint, 4>(count, &rects_size)) {
+    return error::kOutOfBounds;
+  }
+  if (rects_size > immediate_data_size) {
+    return error::kOutOfBounds;
+  }
+  volatile const GLint* rects = GetImmediateDataAs<volatile const GLint*>(
+      c, rects_size, immediate_data_size);
+  GLbitfield flags = static_cast<GLbitfield>(c.flags);
+  if (count < 0) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glSwapBuffersWithBoundsCHROMIUM",
+                       "count < 0");
+    return error::kNoError;
+  }
+  if (rects == nullptr) {
+    return error::kOutOfBounds;
+  }
+  if (!validators_->swap_buffers_flags.IsValid(flags)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glSwapBuffersWithBoundsCHROMIUM",
+                       "flags GL_INVALID_VALUE");
+    return error::kNoError;
+  }
+  DoSwapBuffersWithBoundsCHROMIUM(swap_id, count, rects, flags);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleSetDrawRectangleCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SetDrawRectangleCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::SetDrawRectangleCHROMIUM*>(
+          cmd_data);
+  GLint x = static_cast<GLint>(c.x);
+  GLint y = static_cast<GLint>(c.y);
+  GLint width = static_cast<GLint>(c.width);
+  GLint height = static_cast<GLint>(c.height);
+  DoSetDrawRectangleCHROMIUM(x, y, width, height);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleSetEnableDCLayersCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SetEnableDCLayersCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::SetEnableDCLayersCHROMIUM*>(
+          cmd_data);
+  GLboolean enabled = static_cast<GLboolean>(c.enabled);
+  DoSetEnableDCLayersCHROMIUM(enabled);
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderImpl::HandleTexStorage2DImageCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
index ea65b46b675de..8bca276280ecb 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
@@ -3051,7 +3051,8 @@ error::Error GLES2DecoderPassthroughImpl::CheckSwapBuffersResult(
     gfx::SwapResult result,
     const char* function_name) {
   if (result == gfx::SwapResult::SWAP_FAILED) {
-    // If SwapBuffers failed, we may not have a current context any more.
+    // If SwapBuffers/SwapBuffersWithBounds/PostSubBuffer failed, we may not
+    // have a current context any more.
     LOG(ERROR) << "Context lost because " << function_name << " failed.";
     if (!context_->IsCurrent(surface_.get()) || !CheckResetStatus()) {
       MarkContextLost(error::kUnknown);
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
index e46b8ae80ec8a..9c6cbf6f8e1b3 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
@@ -884,6 +884,9 @@ class GPU_GLES2_EXPORT GLES2DecoderPassthroughImpl
 
   GLuint linking_program_service_id_ = 0u;
 
+  // CA Layer state
+  std::unique_ptr<CALayerSharedState> ca_layer_shared_state_;
+
   base::WeakPtrFactory<GLES2DecoderPassthroughImpl> weak_ptr_factory_{this};
 
   class ScopedEnableTextureRectangleInShaderCompiler;
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
index 8cb86a0044e0a..5b1d76ec5d2d6 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
@@ -824,6 +824,16 @@ error::Error DoGetUniformsES3CHROMIUM(GLuint program,
                                       std::vector<uint8_t>* data);
 error::Error DoGetTranslatedShaderSourceANGLE(GLuint shader,
                                               std::string* source);
+error::Error DoSwapBuffersWithBoundsCHROMIUM(uint64_t swap_id,
+                                             GLsizei count,
+                                             const volatile GLint* rects,
+                                             GLbitfield flags);
+error::Error DoPostSubBufferCHROMIUM(uint64_t swap_id,
+                                     GLint x,
+                                     GLint y,
+                                     GLint width,
+                                     GLint height,
+                                     GLbitfield flags);
 error::Error DoCopyTextureCHROMIUM(GLuint source_id,
                                    GLint source_level,
                                    GLenum dest_target,
@@ -891,6 +901,59 @@ error::Error DoWaitSyncTokenCHROMIUM(CommandBufferNamespace namespace_id,
                                      GLuint64 release_count);
 error::Error DoDrawBuffersEXT(GLsizei count, const volatile GLenum* bufs);
 error::Error DoDiscardBackbufferCHROMIUM();
+error::Error DoScheduleOverlayPlaneCHROMIUM(GLint plane_z_order,
+                                            GLenum plane_transform,
+                                            GLuint overlay_texture_id,
+                                            GLint bounds_x,
+                                            GLint bounds_y,
+                                            GLint bounds_width,
+                                            GLint bounds_height,
+                                            GLfloat uv_x,
+                                            GLfloat uv_y,
+                                            GLfloat uv_width,
+                                            GLfloat uv_height,
+                                            bool enable_blend,
+                                            GLuint gpu_fence_id);
+error::Error DoScheduleCALayerSharedStateCHROMIUM(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    const GLfloat* rounded_corner_bounds,
+    GLint sorting_context_id,
+    const GLfloat* transform);
+error::Error DoScheduleCALayerCHROMIUM(GLuint contents_texture_id,
+                                       const GLfloat* contents_rect,
+                                       GLuint background_color,
+                                       GLuint edge_aa_mask,
+                                       GLenum filter,
+                                       const GLfloat* bounds_rect);
+error::Error DoScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei n,
+    const volatile GLuint* textures);
+error::Error DoScheduleDCLayerCHROMIUM(GLuint texture_0,
+                                       GLuint texture_1,
+                                       GLint z_order,
+                                       GLint content_x,
+                                       GLint content_y,
+                                       GLint content_width,
+                                       GLint content_height,
+                                       GLint quad_x,
+                                       GLint quad_y,
+                                       GLint quad_width,
+                                       GLint quad_height,
+                                       GLfloat transform_c1r1,
+                                       GLfloat transform_c2r1,
+                                       GLfloat transform_c1r2,
+                                       GLfloat transform_c2r2,
+                                       GLfloat transform_tx,
+                                       GLfloat transform_ty,
+                                       GLboolean is_clipped,
+                                       GLint clip_x,
+                                       GLint clip_y,
+                                       GLint clip_width,
+                                       GLint clip_height,
+                                       GLuint protected_video_type);
+error::Error DoCommitOverlayPlanesCHROMIUM(uint64_t swap_id, GLbitfield flags);
 error::Error DoSetColorSpaceMetadataCHROMIUM(GLuint texture_id,
                                              gfx::ColorSpace color_space);
 error::Error DoFlushDriverCachesCHROMIUM();
@@ -1011,6 +1074,12 @@ error::Error DoGetFragDataIndexEXT(GLuint program,
                                    const char* name,
                                    GLint* index);
 
+error::Error DoSetDrawRectangleCHROMIUM(GLint x,
+                                        GLint y,
+                                        GLint width,
+                                        GLint height);
+error::Error DoSetEnableDCLayersCHROMIUM(GLboolean enable);
+
 error::Error DoWindowRectanglesEXT(GLenum mode,
                                    GLsizei n,
                                    const volatile GLint* box);
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
index 8ae038ad25c71..94e24659f73b3 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
@@ -3840,6 +3840,8 @@ error::Error GLES2DecoderPassthroughImpl::DoBindVertexArrayOES(GLuint array) {
 
 error::Error GLES2DecoderPassthroughImpl::DoSwapBuffers(uint64_t swap_id,
                                                         GLbitfield flags) {
+  ca_layer_shared_state_ = nullptr;
+
   if (offscreen_) {
     if (offscreen_single_buffer_) {
       return error::kNoError;
@@ -4464,6 +4466,64 @@ error::Error GLES2DecoderPassthroughImpl::DoGetTranslatedShaderSourceANGLE(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderPassthroughImpl::DoSwapBuffersWithBoundsCHROMIUM(
+    uint64_t swap_id,
+    GLsizei count,
+    const volatile GLint* rects,
+    GLbitfield flags) {
+  if (count < 0) {
+    InsertError(GL_INVALID_VALUE, "count cannot be negative.");
+    return error::kNoError;
+  }
+
+  ca_layer_shared_state_ = nullptr;
+
+  std::vector<gfx::Rect> bounds(count);
+  for (GLsizei i = 0; i < count; ++i) {
+    bounds[i] = gfx::Rect(rects[i * 4 + 0], rects[i * 4 + 1], rects[i * 4 + 2],
+                          rects[i * 4 + 3]);
+  }
+
+  client()->OnSwapBuffers(swap_id, flags);
+  return CheckSwapBuffersResult(
+      surface_->SwapBuffersWithBounds(bounds, base::DoNothing()),
+      "SwapBuffersWithBounds");
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoPostSubBufferCHROMIUM(
+    uint64_t swap_id,
+    GLint x,
+    GLint y,
+    GLint width,
+    GLint height,
+    GLbitfield flags) {
+  if (!surface_->SupportsPostSubBuffer()) {
+    InsertError(GL_INVALID_OPERATION,
+                "glPostSubBufferCHROMIUM is not supported for this surface.");
+    return error::kNoError;
+  }
+
+  ca_layer_shared_state_ = nullptr;
+
+  client()->OnSwapBuffers(swap_id, flags);
+  if (surface_->SupportsAsyncSwap()) {
+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(
+        "gpu", "AsyncSwapBuffers",
+        TRACE_ID_WITH_SCOPE("AsyncSwapBuffers", swap_id));
+    surface_->PostSubBufferAsync(
+        x, y, width, height,
+        base::BindOnce(
+            &GLES2DecoderPassthroughImpl::CheckSwapBuffersAsyncResult,
+            weak_ptr_factory_.GetWeakPtr(), "PostSubBuffer", swap_id),
+        base::DoNothing());
+    return error::kNoError;
+  } else {
+    return CheckSwapBuffersResult(
+        surface_->PostSubBuffer(x, y, width, height, base::DoNothing()),
+        "PostSubBuffer");
+  }
+}
+
 error::Error GLES2DecoderPassthroughImpl::DoCopyTextureCHROMIUM(
     GLuint source_id,
     GLint source_level,
@@ -4735,6 +4795,289 @@ error::Error GLES2DecoderPassthroughImpl::DoDiscardBackbufferCHROMIUM() {
   return error::kNoError;
 }
 
+error::Error GLES2DecoderPassthroughImpl::DoScheduleOverlayPlaneCHROMIUM(
+    GLint plane_z_order,
+    GLenum plane_transform,
+    GLuint overlay_texture_id,
+    GLint bounds_x,
+    GLint bounds_y,
+    GLint bounds_width,
+    GLint bounds_height,
+    GLfloat uv_x,
+    GLfloat uv_y,
+    GLfloat uv_width,
+    GLfloat uv_height,
+    bool enable_blend,
+    GLuint gpu_fence_id) {
+  scoped_refptr<TexturePassthrough> passthrough_texture;
+  if (!resources_->texture_object_map.GetServiceID(overlay_texture_id,
+                                                   &passthrough_texture) ||
+      passthrough_texture == nullptr) {
+    InsertError(GL_INVALID_VALUE, "invalid texture id");
+    return error::kNoError;
+  }
+
+  gl::GLImage* image =
+      passthrough_texture->GetLevelImage(passthrough_texture->target(), 0);
+  if (!image) {
+    InsertError(GL_INVALID_VALUE, "texture has no image");
+    return error::kNoError;
+  }
+
+  gfx::OverlayTransform transform = GetGFXOverlayTransform(plane_transform);
+  if (transform == gfx::OVERLAY_TRANSFORM_INVALID) {
+    InsertError(GL_INVALID_ENUM, "invalid transform enum");
+    return error::kNoError;
+  }
+
+  std::unique_ptr<gfx::GpuFence> gpu_fence;
+  if (gpu_fence_id != 0) {
+    gpu_fence = GetGpuFenceManager()->GetGpuFence(gpu_fence_id);
+    if (!gpu_fence) {
+      InsertError(GL_INVALID_ENUM, "unknown fence");
+      return error::kNoError;
+    }
+  }
+
+  if (!surface_->ScheduleOverlayPlane(
+          image, std::move(gpu_fence),
+          gfx::OverlayPlaneData(
+              plane_z_order, transform,
+              gfx::RectF(bounds_x, bounds_y, bounds_width, bounds_height),
+              gfx::RectF(uv_x, uv_y, uv_width, uv_height), enable_blend,
+              /*damage_rect=*/gfx::Rect(), /*opacity=*/1.0f,
+              gfx::OverlayPriorityHint::kNone,
+              /*rounded_corners*/ gfx::RRectF(), image->color_space(),
+              /*hdr_metadata=*/absl::nullopt))) {
+    InsertError(GL_INVALID_OPERATION, "failed to schedule overlay");
+    return error::kNoError;
+  }
+
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerSharedStateCHROMIUM(
+    GLfloat opacity,
+    GLboolean is_clipped,
+    const GLfloat* clip_rect,
+    const GLfloat* rounded_corner_bounds,
+    GLint sorting_context_id,
+    const GLfloat* transform) {
+  if (!ca_layer_shared_state_) {
+    ca_layer_shared_state_ = std::make_unique<CALayerSharedState>();
+  }
+
+  ca_layer_shared_state_->opacity = opacity;
+  ca_layer_shared_state_->is_clipped = is_clipped;
+  ca_layer_shared_state_->clip_rect = gfx::ToEnclosingRect(
+      gfx::RectF(clip_rect[0], clip_rect[1], clip_rect[2], clip_rect[3]));
+
+  ca_layer_shared_state_->rounded_corner_bounds =
+      gfx::RRectF(rounded_corner_bounds[0], rounded_corner_bounds[1],
+                  rounded_corner_bounds[2], rounded_corner_bounds[3],
+                  rounded_corner_bounds[4]);
+  ca_layer_shared_state_->sorting_context_id = sorting_context_id;
+  ca_layer_shared_state_->transform =
+      gfx::Transform(transform[0], transform[4], transform[8], transform[12],
+                     transform[1], transform[5], transform[9], transform[13],
+                     transform[2], transform[6], transform[10], transform[14],
+                     transform[3], transform[7], transform[11], transform[15]);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerCHROMIUM(
+    GLuint contents_texture_id,
+    const GLfloat* contents_rect,
+    GLuint background_color,
+    GLuint edge_aa_mask,
+    GLenum filter,
+    const GLfloat* bounds_rect) {
+  if (!ca_layer_shared_state_) {
+    InsertError(GL_INVALID_OPERATION,
+                "glScheduleCALayerSharedStateCHROMIUM has not been called");
+    return error::kNoError;
+  }
+
+  gl::GLImage* image = nullptr;
+  if (contents_texture_id) {
+    scoped_refptr<TexturePassthrough> passthrough_texture;
+    if (!resources_->texture_object_map.GetServiceID(contents_texture_id,
+                                                     &passthrough_texture) ||
+        passthrough_texture == nullptr) {
+      InsertError(GL_INVALID_VALUE, "unknown texture");
+      return error::kNoError;
+    }
+    DCHECK(passthrough_texture);
+    image =
+        passthrough_texture->GetLevelImage(passthrough_texture->target(), 0);
+    if (!image) {
+      InsertError(GL_INVALID_VALUE, "unsupported texture format");
+      return error::kNoError;
+    }
+  }
+
+  ui::CARendererLayerParams params = ui::CARendererLayerParams(
+      ca_layer_shared_state_->is_clipped, ca_layer_shared_state_->clip_rect,
+      ca_layer_shared_state_->rounded_corner_bounds,
+      ca_layer_shared_state_->sorting_context_id,
+      ca_layer_shared_state_->transform, image,
+      gfx::RectF(contents_rect[0], contents_rect[1], contents_rect[2],
+                 contents_rect[3]),
+      gfx::ToEnclosingRect(gfx::RectF(bounds_rect[0], bounds_rect[1],
+                                      bounds_rect[2], bounds_rect[3])),
+      background_color, edge_aa_mask, ca_layer_shared_state_->opacity, filter,
+      gfx::ProtectedVideoType::kClear);
+  if (!surface_->ScheduleCALayer(params)) {
+    InsertError(GL_INVALID_OPERATION, "failed to schedule CALayer");
+    return error::kNoError;
+  }
+
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerInUseQueryCHROMIUM(
+    GLsizei n,
+    const volatile GLuint* textures) {
+  // Validate that count is non-negative before allocating a vector
+  if (n < 0) {
+    InsertError(GL_INVALID_VALUE, "count cannot be negative.");
+    return error::kNoError;
+  }
+
+  std::vector<gl::GLSurface::CALayerInUseQuery> queries;
+  queries.reserve(n);
+  for (GLsizei i = 0; i < n; ++i) {
+    gl::GLImage* image = nullptr;
+    GLuint texture_id = textures[i];
+    if (texture_id) {
+      // If a |texture_id| is invalid (due to a client error), report that it
+      // is not in use. Failing the GL call can result in compositor hangs.
+      // https://crbug.com/1120795
+      scoped_refptr<TexturePassthrough> passthrough_texture;
+      if (resources_->texture_object_map.GetServiceID(texture_id,
+                                                      &passthrough_texture)) {
+        if (passthrough_texture) {
+          image = passthrough_texture->GetLevelImage(
+              passthrough_texture->target(), 0);
+        }
+      }
+    }
+    gl::GLSurface::CALayerInUseQuery query;
+    query.image = image;
+    query.texture = texture_id;
+    queries.push_back(query);
+  }
+
+  surface_->ScheduleCALayerInUseQuery(std::move(queries));
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoScheduleDCLayerCHROMIUM(
+    GLuint texture_0,
+    GLuint texture_1,
+    GLint z_order,
+    GLint content_x,
+    GLint content_y,
+    GLint content_width,
+    GLint content_height,
+    GLint quad_x,
+    GLint quad_y,
+    GLint quad_width,
+    GLint quad_height,
+    GLfloat transform_c1r1,
+    GLfloat transform_c2r1,
+    GLfloat transform_c1r2,
+    GLfloat transform_c2r2,
+    GLfloat transform_tx,
+    GLfloat transform_ty,
+    GLboolean is_clipped,
+    GLint clip_x,
+    GLint clip_y,
+    GLint clip_width,
+    GLint clip_height,
+    GLuint protected_video_type) {
+  if (protected_video_type >
+      static_cast<GLuint>(gfx::ProtectedVideoType::kMaxValue)) {
+    InsertError(GL_INVALID_VALUE, "invalid protected video type");
+    return error::kNoError;
+  }
+
+  if (!texture_0) {
+    InsertError(GL_INVALID_VALUE, "invalid texture");
+    return error::kNoError;
+  }
+
+  std::unique_ptr<ui::DCRendererLayerParams> params =
+      std::make_unique<ui::DCRendererLayerParams>();
+  GLuint texture_ids[] = {texture_0, texture_1};
+  size_t i = 0;
+  for (GLuint texture_id : texture_ids) {
+    if (!texture_id)
+      break;
+    scoped_refptr<TexturePassthrough> passthrough_texture;
+    if (!resources_->texture_object_map.GetServiceID(texture_id,
+                                                     &passthrough_texture) ||
+        passthrough_texture == nullptr) {
+      InsertError(GL_INVALID_VALUE, "unknown texture");
+      return error::kNoError;
+    }
+    DCHECK(passthrough_texture);
+    gl::GLImage* image =
+        passthrough_texture->GetLevelImage(passthrough_texture->target(), 0);
+    if (!image) {
+      InsertError(GL_INVALID_VALUE, "unsupported texture format");
+      return error::kNoError;
+    }
+    params->images[i++] = scoped_refptr<gl::GLImage>(image);
+  }
+  params->z_order = z_order;
+  params->content_rect =
+      gfx::Rect(content_x, content_y, content_width, content_height);
+  params->quad_rect = gfx::Rect(quad_x, quad_y, quad_width, quad_height);
+  params->transform =
+      gfx::Transform(transform_c1r1, transform_c2r1, transform_c1r2,
+                     transform_c2r2, transform_tx, transform_ty);
+  if (is_clipped) {
+    params->clip_rect = gfx::Rect(clip_x, clip_y, clip_width, clip_height);
+  }
+  params->protected_video_type =
+      static_cast<gfx::ProtectedVideoType>(protected_video_type);
+
+  if (!surface_->ScheduleDCLayer(std::move(params)))
+    InsertError(GL_INVALID_OPERATION, "failed to schedule DCLayer");
+
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoCommitOverlayPlanesCHROMIUM(
+    uint64_t swap_id,
+    GLbitfield flags) {
+  if (!surface_->SupportsCommitOverlayPlanes()) {
+    InsertError(GL_INVALID_OPERATION,
+                "glCommitOverlayPlanes not supported by surface.");
+    return error::kNoError;
+  }
+
+  ca_layer_shared_state_ = nullptr;
+
+  client()->OnSwapBuffers(swap_id, flags);
+  if (surface_->SupportsAsyncSwap()) {
+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(
+        "gpu", "AsyncSwapBuffers",
+        TRACE_ID_WITH_SCOPE("AsyncSwapBuffers", swap_id));
+    surface_->CommitOverlayPlanesAsync(
+        base::BindOnce(
+            &GLES2DecoderPassthroughImpl::CheckSwapBuffersAsyncResult,
+            weak_ptr_factory_.GetWeakPtr(), "CommitOverlayPlanes", swap_id),
+        base::DoNothing());
+    return error::kNoError;
+  } else {
+    return CheckSwapBuffersResult(
+        surface_->CommitOverlayPlanes(base::DoNothing()),
+        "CommitOverlayPlanes");
+  }
+}
+
 error::Error GLES2DecoderPassthroughImpl::DoSetColorSpaceMetadataCHROMIUM(
     GLuint texture_id,
     gfx::ColorSpace color_space) {
@@ -4806,6 +5149,66 @@ error::Error GLES2DecoderPassthroughImpl::DoGetFragDataIndexEXT(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderPassthroughImpl::DoSetDrawRectangleCHROMIUM(
+    GLint x,
+    GLint y,
+    GLint width,
+    GLint height) {
+  GLint current_framebuffer = 0;
+  api()->glGetIntegervFn(GL_FRAMEBUFFER_BINDING, &current_framebuffer);
+  if (current_framebuffer != 0) {
+    InsertError(GL_INVALID_OPERATION, "framebuffer must not be bound.");
+    return error::kNoError;
+  }
+
+  if (!surface_->SupportsDCLayers()) {
+    InsertError(GL_INVALID_OPERATION,
+                "surface doesn't support SetDrawRectangle.");
+    return error::kNoError;
+  }
+
+  gfx::Rect rect(x, y, width, height);
+  if (!surface_->SetDrawRectangle(rect)) {
+    InsertError(GL_INVALID_OPERATION, "SetDrawRectangle failed on surface");
+    // If SetDrawRectangle failed, we may not have a current context any
+    // more, make sure to report lost context.
+    MarkContextLost(error::kUnknown);
+    group_->LoseContexts(error::kUnknown);
+    return error::kLostContext;
+  }
+
+  ApplySurfaceDrawOffset();
+
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::DoSetEnableDCLayersCHROMIUM(
+    GLboolean enable) {
+  GLint current_framebuffer = 0;
+  api()->glGetIntegervFn(GL_FRAMEBUFFER_BINDING, &current_framebuffer);
+  if (current_framebuffer != 0) {
+    InsertError(GL_INVALID_OPERATION, "framebuffer must not be bound.");
+    return error::kNoError;
+  }
+
+  if (!surface_->SupportsDCLayers()) {
+    InsertError(GL_INVALID_OPERATION,
+                "surface doesn't support SetDrawRectangle.");
+    return error::kNoError;
+  }
+
+  if (!surface_->SetEnableDCLayers(!!enable)) {
+    InsertError(GL_INVALID_OPERATION, "SetEnableDCLayers failed on surface.");
+    // If SetEnableDCLayers failed, we may not have a current context any
+    // more, make sure to report lost context.
+    MarkContextLost(error::kUnknown);
+    group_->LoseContexts(error::kUnknown);
+    return error::kLostContext;
+  }
+
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderPassthroughImpl::DoWindowRectanglesEXT(
     GLenum mode,
     GLsizei n,
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
index 785068f9c6f1b..5e8c41de6eb7d 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
@@ -1753,6 +1753,22 @@ error::Error GLES2DecoderPassthroughImpl::HandleGetTranslatedShaderSourceANGLE(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderPassthroughImpl::HandlePostSubBufferCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::PostSubBufferCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::PostSubBufferCHROMIUM*>(
+          cmd_data);
+  GLint x = static_cast<GLint>(c.x);
+  GLint y = static_cast<GLint>(c.y);
+  GLint width = static_cast<GLint>(c.width);
+  GLint height = static_cast<GLint>(c.height);
+  GLuint64 swap_id = static_cast<GLuint64>(c.swap_id());
+  GLbitfield flags = static_cast<GLbitfield>(c.flags);
+
+  return DoPostSubBufferCHROMIUM(swap_id, x, y, width, height, flags);
+}
+
 error::Error GLES2DecoderPassthroughImpl::HandleDrawArraysInstancedANGLE(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -2206,6 +2222,85 @@ error::Error GLES2DecoderPassthroughImpl::HandleDiscardBackbufferCHROMIUM(
   return DoDiscardBackbufferCHROMIUM();
 }
 
+error::Error GLES2DecoderPassthroughImpl::HandleScheduleOverlayPlaneCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleOverlayPlaneCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleOverlayPlaneCHROMIUM*>(
+          cmd_data);
+  GLint plane_z_order = static_cast<GLint>(c.plane_z_order);
+  GLenum plane_transform = static_cast<GLenum>(c.plane_transform);
+  GLuint overlay_texture_id = static_cast<GLuint>(c.overlay_texture_id);
+  GLint bounds_x = static_cast<GLint>(c.bounds_x);
+  GLint bounds_y = static_cast<GLint>(c.bounds_y);
+  GLint bounds_width = static_cast<GLint>(c.bounds_width);
+  GLint bounds_height = static_cast<GLint>(c.bounds_height);
+  GLfloat uv_x = static_cast<GLfloat>(c.uv_x);
+  GLfloat uv_y = static_cast<GLfloat>(c.uv_y);
+  GLfloat uv_width = static_cast<GLfloat>(c.uv_width);
+  GLfloat uv_height = static_cast<GLfloat>(c.uv_height);
+  bool enable_blend = static_cast<bool>(c.enable_blend);
+  GLuint gpu_fence_id = static_cast<GLuint>(c.gpu_fence_id);
+
+  return DoScheduleOverlayPlaneCHROMIUM(
+      plane_z_order, plane_transform, overlay_texture_id, bounds_x, bounds_y,
+      bounds_width, bounds_height, uv_x, uv_y, uv_width, uv_height,
+      enable_blend, gpu_fence_id);
+}
+
+error::Error
+GLES2DecoderPassthroughImpl::HandleScheduleCALayerSharedStateCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerSharedStateCHROMIUM& c =
+      *static_cast<
+          const volatile gles2::cmds::ScheduleCALayerSharedStateCHROMIUM*>(
+          cmd_data);
+  GLfloat opacity = static_cast<GLfloat>(c.opacity);
+  GLboolean is_clipped = static_cast<GLboolean>(c.is_clipped);
+  GLint sorting_context_id = static_cast<GLint>(c.sorting_context_id);
+  uint32_t shm_id = c.shm_id;
+  uint32_t shm_offset = c.shm_offset;
+
+  // 4 for |clip_rect|, 5 for |rounded_corner_bounds|, 16 for |transform|.
+  const GLfloat* mem = GetSharedMemoryAs<const GLfloat*>(shm_id, shm_offset,
+                                                         25 * sizeof(GLfloat));
+  if (!mem) {
+    return error::kOutOfBounds;
+  }
+  const GLfloat* clip_rect = mem + 0;
+  const GLfloat* rounded_corner_bounds = mem + 4;
+  const GLfloat* transform = mem + 9;
+  return DoScheduleCALayerSharedStateCHROMIUM(opacity, is_clipped, clip_rect,
+                                              rounded_corner_bounds,
+                                              sorting_context_id, transform);
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleScheduleCALayerCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleCALayerCHROMIUM*>(
+          cmd_data);
+  GLuint contents_texture_id = static_cast<GLint>(c.contents_texture_id);
+  GLuint background_color = static_cast<GLuint>(c.background_color);
+  GLuint edge_aa_mask = static_cast<GLuint>(c.edge_aa_mask);
+  GLenum filter = static_cast<GLenum>(c.filter);
+  uint32_t shm_id = c.shm_id;
+  uint32_t shm_offset = c.shm_offset;
+
+  const GLfloat* mem = GetSharedMemoryAs<const GLfloat*>(shm_id, shm_offset,
+                                                         8 * sizeof(GLfloat));
+  if (!mem) {
+    return error::kOutOfBounds;
+  }
+  const GLfloat* contents_rect = mem;
+  const GLfloat* bounds_rect = mem + 4;
+  return DoScheduleCALayerCHROMIUM(contents_texture_id, contents_rect,
+                                   background_color, edge_aa_mask, filter,
+                                   bounds_rect);
+}
+
 error::Error GLES2DecoderPassthroughImpl::HandleSetColorSpaceMetadataCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc
index b5352ef5eca68..b98e65033c860 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc
@@ -4385,6 +4385,49 @@ error::Error GLES2DecoderPassthroughImpl::HandleDrawBuffersEXTImmediate(
   return error::kNoError;
 }
 
+error::Error
+GLES2DecoderPassthroughImpl::HandleScheduleCALayerInUseQueryCHROMIUMImmediate(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleCALayerInUseQueryCHROMIUMImmediate& c =
+      *static_cast<const volatile gles2::cmds::
+                       ScheduleCALayerInUseQueryCHROMIUMImmediate*>(cmd_data);
+  GLsizei count = static_cast<GLsizei>(c.count);
+  uint32_t textures_size = 0;
+  if (count >= 0 &&
+      !GLES2Util::ComputeDataSize<GLuint, 1>(count, &textures_size)) {
+    return error::kOutOfBounds;
+  }
+  if (textures_size > immediate_data_size) {
+    return error::kOutOfBounds;
+  }
+  volatile const GLuint* textures = GetImmediateDataAs<volatile const GLuint*>(
+      c, textures_size, immediate_data_size);
+  if (textures == nullptr) {
+    return error::kOutOfBounds;
+  }
+  error::Error error = DoScheduleCALayerInUseQueryCHROMIUM(count, textures);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleCommitOverlayPlanesCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CommitOverlayPlanesCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::CommitOverlayPlanesCHROMIUM*>(
+          cmd_data);
+  GLuint64 swap_id = c.swap_id();
+  GLbitfield flags = static_cast<GLbitfield>(c.flags);
+  error::Error error = DoCommitOverlayPlanesCHROMIUM(swap_id, flags);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderPassthroughImpl::HandleFlushDriverCachesCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -4395,6 +4438,47 @@ error::Error GLES2DecoderPassthroughImpl::HandleFlushDriverCachesCHROMIUM(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderPassthroughImpl::HandleScheduleDCLayerCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::ScheduleDCLayerCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::ScheduleDCLayerCHROMIUM*>(
+          cmd_data);
+  GLuint texture_0 = static_cast<GLuint>(c.texture_0);
+  GLuint texture_1 = static_cast<GLuint>(c.texture_1);
+  GLint z_order = static_cast<GLint>(c.z_order);
+  GLint content_x = static_cast<GLint>(c.content_x);
+  GLint content_y = static_cast<GLint>(c.content_y);
+  GLint content_width = static_cast<GLint>(c.content_width);
+  GLint content_height = static_cast<GLint>(c.content_height);
+  GLint quad_x = static_cast<GLint>(c.quad_x);
+  GLint quad_y = static_cast<GLint>(c.quad_y);
+  GLint quad_width = static_cast<GLint>(c.quad_width);
+  GLint quad_height = static_cast<GLint>(c.quad_height);
+  GLfloat transform_c1r1 = static_cast<GLfloat>(c.transform_c1r1);
+  GLfloat transform_c2r1 = static_cast<GLfloat>(c.transform_c2r1);
+  GLfloat transform_c1r2 = static_cast<GLfloat>(c.transform_c1r2);
+  GLfloat transform_c2r2 = static_cast<GLfloat>(c.transform_c2r2);
+  GLfloat transform_tx = static_cast<GLfloat>(c.transform_tx);
+  GLfloat transform_ty = static_cast<GLfloat>(c.transform_ty);
+  GLboolean is_clipped = static_cast<GLboolean>(c.is_clipped);
+  GLint clip_x = static_cast<GLint>(c.clip_x);
+  GLint clip_y = static_cast<GLint>(c.clip_y);
+  GLint clip_width = static_cast<GLint>(c.clip_width);
+  GLint clip_height = static_cast<GLint>(c.clip_height);
+  GLuint protected_video_type = static_cast<GLuint>(c.protected_video_type);
+  error::Error error = DoScheduleDCLayerCHROMIUM(
+      texture_0, texture_1, z_order, content_x, content_y, content_width,
+      content_height, quad_x, quad_y, quad_width, quad_height, transform_c1r1,
+      transform_c2r1, transform_c1r2, transform_c2r2, transform_tx,
+      transform_ty, is_clipped, clip_x, clip_y, clip_width, clip_height,
+      protected_video_type);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderPassthroughImpl::HandleContextVisibilityHintCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -4441,6 +4525,68 @@ error::Error GLES2DecoderPassthroughImpl::HandleBlendBarrierKHR(
   return error::kNoError;
 }
 
+error::Error
+GLES2DecoderPassthroughImpl::HandleSwapBuffersWithBoundsCHROMIUMImmediate(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate& c =
+      *static_cast<
+          const volatile gles2::cmds::SwapBuffersWithBoundsCHROMIUMImmediate*>(
+          cmd_data);
+  GLuint64 swap_id = c.swap_id();
+  GLsizei count = static_cast<GLsizei>(c.count);
+  uint32_t rects_size = 0;
+  if (count >= 0 && !GLES2Util::ComputeDataSize<GLint, 4>(count, &rects_size)) {
+    return error::kOutOfBounds;
+  }
+  if (rects_size > immediate_data_size) {
+    return error::kOutOfBounds;
+  }
+  volatile const GLint* rects = GetImmediateDataAs<volatile const GLint*>(
+      c, rects_size, immediate_data_size);
+  GLbitfield flags = static_cast<GLbitfield>(c.flags);
+  if (rects == nullptr) {
+    return error::kOutOfBounds;
+  }
+  error::Error error =
+      DoSwapBuffersWithBoundsCHROMIUM(swap_id, count, rects, flags);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleSetDrawRectangleCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SetDrawRectangleCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::SetDrawRectangleCHROMIUM*>(
+          cmd_data);
+  GLint x = static_cast<GLint>(c.x);
+  GLint y = static_cast<GLint>(c.y);
+  GLint width = static_cast<GLint>(c.width);
+  GLint height = static_cast<GLint>(c.height);
+  error::Error error = DoSetDrawRectangleCHROMIUM(x, y, width, height);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleSetEnableDCLayersCHROMIUM(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::SetEnableDCLayersCHROMIUM& c =
+      *static_cast<const volatile gles2::cmds::SetEnableDCLayersCHROMIUM*>(
+          cmd_data);
+  GLboolean enabled = static_cast<GLboolean>(c.enabled);
+  error::Error error = DoSetEnableDCLayersCHROMIUM(enabled);
+  if (error != error::kNoError) {
+    return error;
+  }
+  return error::kNoError;
+}
+
 error::Error GLES2DecoderPassthroughImpl::HandleTexStorage2DImageCHROMIUM(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
index 152deafa562d7..3546e56835a58 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
@@ -221,6 +221,7 @@ ContextResult GLES2DecoderTestBase::MaybeInitDecoderWithWorkarounds(
 
   surface_ = new gl::GLSurfaceStub;
   surface_->SetSize(gfx::Size(kBackBufferWidth, kBackBufferHeight));
+  surface_->set_supports_draw_rectangle(surface_supports_draw_rectangle_);
 
   // Context needs to be created before initializing ContextGroup, which will
   // in turn initialize FeatureInfo, which needs a context to determine
diff --git gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
index 7d08382139018..fd668ef62bf29 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
@@ -702,6 +702,8 @@ class GLES2DecoderTestBase : public ::testing::TestWithParam<bool>,
   std::unique_ptr<MemoryTracker> memory_tracker_;
   raw_ptr<gl::GLDisplay> display_ = nullptr;
 
+  bool surface_supports_draw_rectangle_ = false;
+
   GLuint client_buffer_id_;
   GLuint client_framebuffer_id_;
   GLuint client_program_id_;
diff --git gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc
index f094286e4c164..11aaeb1109d69 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc
@@ -3913,6 +3913,106 @@ TEST_P(GLES3DecoderTest, BlitFramebufferMissingDepthOrStencil) {
   }
 }
 
+class GLES2DecoderTestWithDrawRectangle : public GLES2DecoderTest {
+  void SetUp() override {
+    surface_supports_draw_rectangle_ = true;
+    GLES2DecoderTest::SetUp();
+  }
+};
+
+// Test that the draw offset is correctly honored when SetDrawRectangle is
+// supported.
+TEST_P(GLES2DecoderTestWithDrawRectangle, FramebufferDrawRectangleClear) {
+  EXPECT_CALL(*gl_, Scissor(101, 202, 3, 4)).Times(1).RetiresOnSaturation();
+  cmds::Scissor scissor_cmd;
+  scissor_cmd.Init(1, 2, 3, 4);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(scissor_cmd));
+
+  // Scissor and Viewport should be restored to (0,0) offset on when clearing
+  // a framebuffer.
+  {
+    const GLuint kFBOClientTextureId = 4100;
+    const GLuint kFBOServiceTextureId = 4101;
+
+    // Register a texture id.
+    EXPECT_CALL(*gl_, GenTextures(_, _))
+        .WillOnce(SetArgPointee<1>(kFBOServiceTextureId))
+        .RetiresOnSaturation();
+    GenHelper<cmds::GenTexturesImmediate>(kFBOClientTextureId);
+
+    // Setup "render to" texture.
+    DoBindTexture(GL_TEXTURE_2D, kFBOClientTextureId, kFBOServiceTextureId);
+    DoTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                 0, 0);
+    DoBindFramebuffer(GL_FRAMEBUFFER, client_framebuffer_id_,
+                      kServiceFramebufferId);
+    DoFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+                           kFBOClientTextureId, kFBOServiceTextureId, 0,
+                           GL_NO_ERROR);
+    // Set scissor rect and enable GL_SCISSOR_TEST to make sure we re-enable it
+    // and restore the rect again after the clear.
+    DoEnableDisable(GL_SCISSOR_TEST, true);
+    EXPECT_CALL(*gl_, Viewport(0, 0, 128, 64)).Times(1).RetiresOnSaturation();
+    EXPECT_CALL(*gl_, Scissor(1, 2, 3, 4)).Times(1).RetiresOnSaturation();
+
+    // Setup "render from" texture.
+    SetupTexture();
+
+    SetupExpectationsForFramebufferClearing(GL_FRAMEBUFFER,       // target
+                                            GL_COLOR_BUFFER_BIT,  // clear bits
+                                            0, 0, 0,
+                                            0,     // color
+                                            0,     // stencil
+                                            1.0f,  // depth
+                                            true,  // scissor test
+                                            1, 2, 3, 4);
+    SetupExpectationsForApplyingDirtyState(false,   // Framebuffer is RGB
+                                           false,   // Framebuffer has depth
+                                           false,   // Framebuffer has stencil
+                                           0x1111,  // color bits
+                                           false,   // depth mask
+                                           false,   // depth enabled
+                                           0,       // front stencil mask
+                                           0,       // back stencil mask
+                                           false);  // stencil enabled
+
+    EXPECT_CALL(*gl_, Clear(GL_COLOR_BUFFER_BIT))
+        .Times(1)
+        .RetiresOnSaturation();
+
+    cmds::Clear cmd;
+    cmd.Init(GL_COLOR_BUFFER_BIT);
+    EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+    EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  }
+
+  // Check that the draw offset is used when switching to the default
+  // framebuffer and clearing it.
+  {
+    DoBindFramebuffer(GL_FRAMEBUFFER, 0, 0);
+    EXPECT_CALL(*gl_, Clear(GL_COLOR_BUFFER_BIT))
+        .Times(1)
+        .RetiresOnSaturation();
+    SetupExpectationsForColorMask(true, true, true, true);
+    SetupExpectationsForDepthMask(true);
+    SetupExpectationsForStencilMask(0, 0);
+    SetupExpectationsForEnableDisable(GL_DEPTH_TEST, false);
+    SetupExpectationsForEnableDisable(GL_STENCIL_TEST, false);
+    EXPECT_CALL(*gl_, Viewport(100, 200, 128, 64))
+        .Times(1)
+        .RetiresOnSaturation();
+    EXPECT_CALL(*gl_, Scissor(101, 202, 3, 4)).Times(1).RetiresOnSaturation();
+    cmds::Clear cmd;
+    cmd.Init(GL_COLOR_BUFFER_BIT);
+    EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+    EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  }
+}
+
+INSTANTIATE_TEST_SUITE_P(Service,
+                         GLES2DecoderTestWithDrawRectangle,
+                         ::testing::Bool());
+
 TEST_P(GLES2DecoderManualInitTest, MESAFramebufferFlipYExtensionEnabled) {
   InitState init;
   init.gl_version = "OpenGL ES 3.1";
diff --git gpu/command_buffer/tests/decoder_perftest.cc gpu/command_buffer/tests/decoder_perftest.cc
index 2314394721cae..9c2d6c22dd61c 100644
--- gpu/command_buffer/tests/decoder_perftest.cc
+++ gpu/command_buffer/tests/decoder_perftest.cc
@@ -318,6 +318,8 @@ class RecordReplayContext : public GpuControl {
     return true;
   }
 
+  void SetDisplayTransform(gfx::OverlayTransform) override { NOTREACHED(); }
+
   GpuPreferences gpu_preferences_;
 
   gles2::MailboxManagerImpl mailbox_manager_;
diff --git gpu/command_buffer/tests/gl_manager.cc gpu/command_buffer/tests/gl_manager.cc
index f62d9a5a91b51..0a97dbb17a124 100644
--- gpu/command_buffer/tests/gl_manager.cc
+++ gpu/command_buffer/tests/gl_manager.cc
@@ -543,6 +543,10 @@ bool GLManager::CanWaitUnverifiedSyncToken(const gpu::SyncToken& sync_token) {
   return false;
 }
 
+void GLManager::SetDisplayTransform(gfx::OverlayTransform transform) {
+  NOTREACHED();
+}
+
 ContextType GLManager::GetContextType() const {
   return context_type_;
 }
diff --git gpu/command_buffer/tests/gl_manager.h gpu/command_buffer/tests/gl_manager.h
index 47ac796b187db..bfbef6f581f6f 100644
--- gpu/command_buffer/tests/gl_manager.h
+++ gpu/command_buffer/tests/gl_manager.h
@@ -160,6 +160,7 @@ class GLManager : private GpuControl {
                        base::OnceClosure callback) override;
   void WaitSyncToken(const gpu::SyncToken& sync_token) override;
   bool CanWaitUnverifiedSyncToken(const gpu::SyncToken& sync_token) override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
 
   size_t GetSharedMemoryBytesAllocated() const;
   ContextType GetContextType() const;
diff --git gpu/gles2_conform_support/egl/context.cc gpu/gles2_conform_support/egl/context.cc
index 35fe87474eedd..4d12a4c1563e5 100644
--- gpu/gles2_conform_support/egl/context.cc
+++ gpu/gles2_conform_support/egl/context.cc
@@ -229,6 +229,10 @@ bool Context::CanWaitUnverifiedSyncToken(const gpu::SyncToken& sync_token) {
   return false;
 }
 
+void Context::SetDisplayTransform(gfx::OverlayTransform transform) {
+  NOTREACHED();
+}
+
 void Context::ApplyCurrentContext(gl::GLSurface* current_surface) {
   DCHECK(HasService());
   // The current_surface will be the same as
diff --git gpu/gles2_conform_support/egl/context.h gpu/gles2_conform_support/egl/context.h
index f8d0b38f1fcf8..4c6322b0b6be3 100644
--- gpu/gles2_conform_support/egl/context.h
+++ gpu/gles2_conform_support/egl/context.h
@@ -82,6 +82,7 @@ class Context : public base::RefCountedThreadSafe<Context>,
                        base::OnceClosure callback) override;
   void WaitSyncToken(const gpu::SyncToken& sync_token) override;
   bool CanWaitUnverifiedSyncToken(const gpu::SyncToken& sync_token) override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
 
   // Called by ThreadState to set the needed global variables when this context
   // is current.
diff --git gpu/ipc/client/command_buffer_proxy_impl.cc gpu/ipc/client/command_buffer_proxy_impl.cc
index 7b86140b521f9..8b0fbd40ca854 100644
--- gpu/ipc/client/command_buffer_proxy_impl.cc
+++ gpu/ipc/client/command_buffer_proxy_impl.cc
@@ -534,6 +534,11 @@ void CommandBufferProxyImpl::CreateGpuFence(uint32_t gpu_fence_id,
       gpu_fence_id, gpu_fence->GetGpuFenceHandle().Clone());
 }
 
+void CommandBufferProxyImpl::SetDisplayTransform(
+    gfx::OverlayTransform transform) {
+  NOTREACHED();
+}
+
 void CommandBufferProxyImpl::GetGpuFence(
     uint32_t gpu_fence_id,
     base::OnceCallback<void(std::unique_ptr<gfx::GpuFence>)> callback) {
diff --git gpu/ipc/client/command_buffer_proxy_impl.h gpu/ipc/client/command_buffer_proxy_impl.h
index bc1bf426704fe..82a4c2d52a72e 100644
--- gpu/ipc/client/command_buffer_proxy_impl.h
+++ gpu/ipc/client/command_buffer_proxy_impl.h
@@ -131,6 +131,7 @@ class GPU_EXPORT CommandBufferProxyImpl : public gpu::CommandBuffer,
   void GetGpuFence(uint32_t gpu_fence_id,
                    base::OnceCallback<void(std::unique_ptr<gfx::GpuFence>)>
                        callback) override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
 
   void SetLock(base::Lock* lock) override;
   void EnsureWorkVisible() override;
diff --git gpu/ipc/in_process_command_buffer.cc gpu/ipc/in_process_command_buffer.cc
index bd854ff792fda..33dabf654004b 100644
--- gpu/ipc/in_process_command_buffer.cc
+++ gpu/ipc/in_process_command_buffer.cc
@@ -1293,6 +1293,30 @@ bool InProcessCommandBuffer::CanWaitUnverifiedSyncToken(
   return sync_token.namespace_id() == GetNamespaceID();
 }
 
+void InProcessCommandBuffer::SetDisplayTransform(
+    gfx::OverlayTransform transform) {
+  ScheduleGpuTask(
+      base::BindOnce(&InProcessCommandBuffer::SetDisplayTransformOnGpuThread,
+                     gpu_thread_weak_ptr_factory_.GetWeakPtr(), transform));
+}
+
+void InProcessCommandBuffer::SetDisplayTransformOnGpuThread(
+    gfx::OverlayTransform transform) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
+  surface_->SetDisplayTransform(transform);
+}
+
+void InProcessCommandBuffer::SetFrameRate(float frame_rate) {
+  ScheduleGpuTask(
+      base::BindOnce(&InProcessCommandBuffer::SetFrameRateOnGpuThread,
+                     gpu_thread_weak_ptr_factory_.GetWeakPtr(), frame_rate));
+}
+
+void InProcessCommandBuffer::SetFrameRateOnGpuThread(float frame_rate) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
+  surface_->SetFrameRate(frame_rate);
+}
+
 #if BUILDFLAG(IS_WIN)
 void InProcessCommandBuffer::DidCreateAcceleratedSurfaceChildWindow(
     SurfaceHandle parent_window,
diff --git gpu/ipc/in_process_command_buffer.h gpu/ipc/in_process_command_buffer.h
index 04c353a76625a..e54c38b5ab2c8 100644
--- gpu/ipc/in_process_command_buffer.h
+++ gpu/ipc/in_process_command_buffer.h
@@ -170,6 +170,8 @@ class GL_IN_PROCESS_CONTEXT_EXPORT InProcessCommandBuffer
                        base::OnceClosure callback) override;
   void WaitSyncToken(const SyncToken& sync_token) override;
   bool CanWaitUnverifiedSyncToken(const SyncToken& sync_token) override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
+  void SetFrameRate(float frame_rate) override;
 
   // CommandBufferServiceClient implementation (called on gpu thread):
   CommandBatchProcessedResult OnCommandBatchProcessed() override;
@@ -330,6 +332,8 @@ class GL_IN_PROCESS_CONTEXT_EXPORT InProcessCommandBuffer
   void GetGpuFenceOnGpuThread(
       uint32_t gpu_fence_id,
       base::OnceCallback<void(std::unique_ptr<gfx::GpuFence>)> callback);
+  void SetDisplayTransformOnGpuThread(gfx::OverlayTransform transform);
+  void SetFrameRateOnGpuThread(float frame_rate);
 
   // Sets |active_url_| as the active GPU process URL. Should be called on GPU
   // thread only.
diff --git ppapi/proxy/ppapi_command_buffer_proxy.cc ppapi/proxy/ppapi_command_buffer_proxy.cc
index e92622a7c3c4f..fd3d925b558a4 100644
--- ppapi/proxy/ppapi_command_buffer_proxy.cc
+++ ppapi/proxy/ppapi_command_buffer_proxy.cc
@@ -233,6 +233,11 @@ bool PpapiCommandBufferProxy::CanWaitUnverifiedSyncToken(
   return false;
 }
 
+void PpapiCommandBufferProxy::SetDisplayTransform(
+    gfx::OverlayTransform transform) {
+  NOTREACHED();
+}
+
 void PpapiCommandBufferProxy::SignalQuery(uint32_t query,
                                           base::OnceClosure callback) {
   NOTREACHED();
diff --git ppapi/proxy/ppapi_command_buffer_proxy.h ppapi/proxy/ppapi_command_buffer_proxy.h
index 5fe7d5a889d9e..93372fdc09ad0 100644
--- ppapi/proxy/ppapi_command_buffer_proxy.h
+++ ppapi/proxy/ppapi_command_buffer_proxy.h
@@ -79,6 +79,7 @@ class PPAPI_PROXY_EXPORT PpapiCommandBufferProxy : public gpu::CommandBuffer,
                        base::OnceClosure callback) override;
   void WaitSyncToken(const gpu::SyncToken& sync_token) override;
   bool CanWaitUnverifiedSyncToken(const gpu::SyncToken& sync_token) override;
+  void SetDisplayTransform(gfx::OverlayTransform transform) override;
 
  private:
   bool Send(IPC::Message* msg);
diff --git ui/gl/gl_bindings.h ui/gl/gl_bindings.h
index 09d485c66b46c..d832398f3291e 100644
--- ui/gl/gl_bindings.h
+++ ui/gl/gl_bindings.h
@@ -186,6 +186,14 @@ struct XVisualInfo;
 // GL_CHROMIUM_ycbcr_p010_image
 #define GL_RGB_YCBCR_P010_CHROMIUM 0x78FD
 
+// GL_CHROMIUM_schedule_overlay_plane
+#define GL_OVERLAY_TRANSFORM_NONE_CHROMIUM               0x9245
+#define GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM    0x9246
+#define GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM      0x9247
+#define GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM          0x9248
+#define GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM         0x9249
+#define GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM         0x924A
+
 // GL_CHROMIUM_subscribe_uniforms
 #define GL_SUBSCRIBED_VALUES_BUFFER_CHROMIUM             0x924B
 #define GL_MOUSE_POSITION_CHROMIUM                       0x924C
diff --git ui/gl/gl_enums_implementation_autogen.h ui/gl/gl_enums_implementation_autogen.h
index a3a800e02aba3..7c0f25385bc89 100644
--- ui/gl/gl_enums_implementation_autogen.h
+++ ui/gl/gl_enums_implementation_autogen.h
@@ -612,6 +612,10 @@ static const GLEnums::EnumToString enum_to_string_table[] = {
         0x0F,
         "GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV",
     },
+    {
+        0x1,
+        "GL_CA_LAYER_EDGE_LEFT_CHROMIUM",
+    },
     {
         0x10,
         "GL_SMOOTH_CUBIC_CURVE_TO_NV",
@@ -856,6 +860,10 @@ static const GLEnums::EnumToString enum_to_string_table[] = {
         0x1F03,
         "GL_EXTENSIONS",
     },
+    {
+        0x2,
+        "GL_CA_LAYER_EDGE_RIGHT_CHROMIUM",
+    },
     {
         0x20,
         "GL_GLYPH_VERTICAL_BEARING_X_BIT_NV",
@@ -956,6 +964,10 @@ static const GLEnums::EnumToString enum_to_string_table[] = {
         0x300E,
         "GL_CONTEXT_LOST",
     },
+    {
+        0x4,
+        "GL_CA_LAYER_EDGE_BOTTOM_CHROMIUM",
+    },
     {
         0x40,
         "GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV",
@@ -1024,6 +1036,10 @@ static const GLEnums::EnumToString enum_to_string_table[] = {
         0x78FD,
         "GL_RGB_YCBCR_P010_CHROMIUM",
     },
+    {
+        0x8,
+        "GL_CA_LAYER_EDGE_TOP_CHROMIUM",
+    },
     {
         0x80,
         "GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV",
@@ -5284,6 +5300,30 @@ static const GLEnums::EnumToString enum_to_string_table[] = {
         0x9244,
         "GL_BIND_GENERATES_RESOURCE_CHROMIUM",
     },
+    {
+        0x9245,
+        "GL_OVERLAY_TRANSFORM_NONE_CHROMIUM",
+    },
+    {
+        0x9246,
+        "GL_OVERLAY_TRANSFORM_FLIP_HORIZONTAL_CHROMIUM",
+    },
+    {
+        0x9247,
+        "GL_OVERLAY_TRANSFORM_FLIP_VERTICAL_CHROMIUM",
+    },
+    {
+        0x9248,
+        "GL_OVERLAY_TRANSFORM_ROTATE_90_CHROMIUM",
+    },
+    {
+        0x9249,
+        "GL_OVERLAY_TRANSFORM_ROTATE_180_CHROMIUM",
+    },
+    {
+        0x924A,
+        "GL_OVERLAY_TRANSFORM_ROTATE_270_CHROMIUM",
+    },
     {
         0x9250,
         "GL_SHADER_BINARY_DMP",
-- 
2.36.1.windows.1

